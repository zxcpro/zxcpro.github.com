
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>从零开始实现RPC框架&#8211;(2)实现RPC调用 - xuanchen&#8217;s Blog</title>
	<meta name="author" content="xuanchen.zhao">

	
	<meta name="description" content="在上一篇文章"从零开始实现RPC框架&ndash;(1)基本原理&ldquo;中，大致讲述了RPC框架的原理、可能遇到的问题及一些解决的方案。
之后我实现了RPC框架的基础功能&ndash;客户端和服务端之间的调用，代码已经上传至github（项目链接），大家如果感兴趣可以star一下， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="xuanchen's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">xuanchen&#8217;s Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:zxcpro.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:zxcpro.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">从零开始实现RPC框架&#8211;(2)实现RPC调用</h2>
	<div class="entry-content"><p>在上一篇文章&#8221;<a href="http://zxcpro.github.io/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">从零开始实现RPC框架&ndash;(1)基本原理</a>&ldquo;中，大致讲述了RPC框架的原理、可能遇到的问题及一些解决的方案。<br/>
之后我实现了RPC框架的基础功能&ndash;客户端和服务端之间的调用，代码已经上传至github（<a href="https://github.com/zxcpro/zing">项目链接</a>），大家如果感兴趣可以star一下，今天这篇主要结合代码说说如何实现RPC框架的调用功能。</p>

<!--more-->


<p>这个版本tag名为&#8221;getting-through&#8221;，目前客户端选择服务端地址时暂时以常量形式设置，服务注册发现和负载均衡的特性会在下一个版本完成，本次主要功能放在客户端和服务端之间的调用过程的实现上。</p>

<h1>PRC调用的实现</h1>

<p>RPC框架主要可以分为启动和服务调用两个阶段，下面分阶段分别来看客户端和服务端的实现：</p>

<h2>1.启动阶段</h2>

<h3>1.1 客户端启动&ndash;初始化代理类</h3>

<h4>像本地方法一样调用</h4>

<p>客户端在启动时，需要为客户端所依赖的各个service生成各自的proxy bean，并且借助spring在启动时注入到对应的业务组件中，proxy bean应该拥有和service完全相同的接口，来接管所有对service的方法调用</p>

<p>以一个sayHello例子为例，程序很简单，客户端告知我是“zxc”，服务端返回”Hello zxc!”：</p>

<p>HelloService接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HelloService</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实现类HelloServiceImpl：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServiceImpl</span> <span class="kd">implements</span> <span class="n">HelloService</span> <span class="o">{</span>
</span><span class='line'>     <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="err">“</span><span class="n">Hello</span> <span class="err">&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在进行远程调用的时候，把HelloService接口作为api的一部分，单独打jar包，再由客户端应用引用。</p>

<p>我们的目标要达到的效果是能够在客户端代码中自然的进行调用，效果如代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClientBiz</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Autowired</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">HelloService</span> <span class="n">helloService</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">helloService</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="s">&quot;zxc&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注入的service bean并不是HelloServiceImpl，因为HelloServiceImpl并不在客户端上，这个bean只是实现了HelloService接口的动态代理类，在调用时其真正的行为是发起一次rpc调用。</p>

<h4>代理类的实现方法</h4>

<p>代理类可以利用JDK中的动态代理方式来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Object</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">classLoader</span><span class="o">,</span> <span class="n">interfaceClassList</span><span class="o">,</span> <span class="n">invocationHandler</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是classLoader <br/>
第二个参数是要代理的接口的class的list，事例中是只有一个元素即HelloService.class的list<br/>
第三个参数是InvocationHandler，代理类的主逻辑就在这里，需要实现其invoke接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">ServiceProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//proxy logic here</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里invoke接口参数中，obj参数就是之前newProxyInstance所返回的proxy，在客户端调用的那个对象；method就是调用的方法，在例子中就是sayHello方法；arguments是此次调用所传入的参数队列，在例子中是String类型的&#8221;zxc&#8221;。</p>

<p>这样就得到一个有着HelloService接口的代理类，这个类上任何方法的调用都会被传递给内部实现了InvocationHanlder接口的代理来处理</p>

<p>PS： <br/>
google的guava框架对动态代理相关类Proxy.newProxyInstance和InvocationHandler也有对应的封装，分别是Reflection.newProxy和AbstractInvocationHandler：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//隐藏了classLoader的逻辑，并且支持泛型，也就是直接返回HelloService类型的对象</span>
</span><span class='line'><span class="n">HelloService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">Reflection</span><span class="o">.</span><span class="na">newProxy</span><span class="o">(</span><span class="n">serviceClass</span><span class="o">,</span> <span class="n">invocationHandler</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractInvocationHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//先排除 hashCode,equals,toString 的调用</span>
</span><span class='line'>        <span class="c1">//只将有意义的调用传递给handlerInvocation方法</span>
</span><span class='line'>        <span class="n">handleInvocation</span><span class="o">(</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>让代码更加简单优雅。</p>

<h4>让spring管理代理类的生命周期</h4>

<p>代理类需要spring来管理其生命周期，才能完成代理类到业务Biz的注入，定义代理类的bean：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.client.proxy.ServiceProxyBeanFactory&quot;</span> <span class="n">factory</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;getService&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.api.HelloService&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>ServiceProxyBeanFactory是代理的工厂类，getService是工厂方法，而生成代理bean的参数，目前为止，只需要一个类的全名，以得到对应的class来生成代理类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProxyBeanFactory</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">serviceClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Reflection</span><span class="o">.</span><span class="na">newProxy</span><span class="o">(</span><span class="n">serviceClass</span><span class="o">,</span> <span class="k">new</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="n">serviceName</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，启动阶段客户端的初始化就完成了，这些被注入到客户端业务逻辑中的代理配在之后调用阶段就会派上用场。</p>

<h3>1.2 服务端启动&ndash;加载service接口到实现的映射并启动netty</h3>

<h4>加载service接口到实现类映射</h4>

<p>在服务端，我们有接口HelloService及其实现类HelloServiceImpl，要保证在rpc请求到来时能找到要请求服务对应的实现逻辑，就需要在服务启动之时在内存中维护好这个映射。</p>

<p>还是借助spring定义这些bean：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.service.impl.HelloServiceImpl&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.server.remote.RemoteServiceBean&quot;</span> <span class="n">init</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;init&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;serviceName&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.api.HelloService&quot;</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;serviceImpl&quot;</span> <span class="n">ref</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>RemoteServiceBean中有两个参数，serviceName即之前和客户端统一的服务接口类的全名，serviceImpl即服务接口对应的服务实现类。<br/>
我们把这个映射用一个静态类的静态成员Map&lt;String, Object>的方式维护在内存中，并且在spring加载这个bean的时候执行init方法，把当前的Impl加入Map。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceBean</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceName</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">addService</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceServer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">serviceImplMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">,</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然目前只有spring加载bean初始化时串行的进行add，但之后可能涉及到一些场景在其它时机对map进行增删，比如管理服务时需要停止/恢复提供某个service，先用一个ConcurrentHashMap来保证线程安全。</p>

<p>随着spring bean一个个加载完成，服务接口到实现类的映射也就加载完毕了。</p>

<p>可以看到，在addService之前还有一个startup方法，即启动netty服务，下面就来看看netty服务的启动。</p>

<h4>启动netty服务</h4>

<p>之前说rpc服务端启动时需要加载服务映射和启动netty服务两件事，先后顺序是怎样的呢？ <br/>
考虑到之后有了服务注册中心，服务端加载完service bean的时候要告知注册中心这台服务器可以提供该service的服务，这样客户端就能拿到这台服务端的地址从而发送请求，期望请求到来之时服务端应该是已经启动好的，也就是说启动netty服务最好在加载service bean之前完成。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceServer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">started</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">serviceImplMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">bootstrap</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">,</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bootstrap</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">doStartup</span><span class="o">();</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doStartup</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//netty bootstrap</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getActualServiceImpl</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;server not started&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">bootstrap</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;cur map when get:&quot;</span><span class="o">+</span><span class="n">serviceImplMap</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在RemoteServiceServer的静态块中执行启动，当spring加载第一个RemoteServiceBean并执行其init方法时，RemoteServiceServer.addService时JVM加载RemoteServiceServer类，进而执行启动bootstrap流程。<br/>
除去服务端第一次启动时需要执行bootstrap之外，考虑到后续可能在某些情况下，比如初始化启动失败，在请求到来时发现服务未能启动成功而重试启动等，用volatile的started标志位加上double-check的方式对bootstrap做一个并发的控制以保证线程安全。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doStart</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">bossGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">workerGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ServerBootstrap</span> <span class="n">bootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ServerBootstrap</span><span class="o">();</span>
</span><span class='line'>    <span class="n">bootstrap</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossGroup</span><span class="o">,</span> <span class="n">workerGroup</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="n">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelInitializer</span><span class="o">&lt;</span><span class="n">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>                <span class="nd">@Override</span>
</span><span class='line'>                <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyServerHandler</span><span class="o">());</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}).</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bootstrap</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="mi">8080</span><span class="o">).</span><span class="na">sync</span><span class="o">();</span>
</span><span class='line'>        <span class="n">f</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ChannelFutureListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationComplete</span><span class="o">(</span><span class="n">ChannelFuture</span> <span class="n">future</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">isSuccess</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">started</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;server started!&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;server started failed:&quot;</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>doStart中调用netty的api进行启动： <br/>
EventLoop可以理解为类似守护进程，不断处理到来的请求，这里定义了一个bossGroup，一个workerGroup，bossGroup接收请求后分发给workerGroup，workerGroup在自己的线程池中处理这些请求。 <br/>
数据到达当前机器，服务端进行逻辑处理，处理完成的数据传输回去这些逻辑都是依赖ChannelHandler来实现，代码中我们定义的NettyDecoder，NettyEncoder，NettyServerHandler都是ChannelHandler，具体的机制在调用阶段详述。</p>

<p>PS：
netty是一个nio的通讯框架，屏蔽了很多的底层网络细节，api封装的简单易用，对netty不太了解的同学，可以参考<a href="http://netty.io/wiki/user-guide.html">官方UserGuide</a>，netty 3.x/4.x/5.x版本api有较大的差异，本项目依赖的是4.0.32版本。</p>

<p>这样，客户端完成了服务代理类的注入，服务端启动了netty并加载了service对应的实现，一切就绪等待RPC调用开始。</p>

<h2>2.调用阶段</h2>

<p><a href="http://zxcpro.github.io/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">上一篇文章</a>中主要描述了一次RPC调用的过程，为了读起来方便，这里再引用一遍： <br/>
<img src="/assets/img/rpc/rpcflow.png" alt="RPC调用流程" /></p>

<ol>
<li>客户端调用了某个服务的某个方法，期望得到处理的结果</li>
<li>把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</li>
<li>根据被调用的服务名，方法签名等信息找到可以提供服务的server列表</li>
<li>根据负载均衡的规则，选出其中一个server作为目标来调用</li>
<li>向选出的server发送该请求，客户端线程挂起</li>
<li>server接收到请求，反序列并解析得到对应的服务名，方法签名，参数信息</li>
<li>server根据调用信息找到真正的业务服务实例，调用业务服务该方法</li>
<li>把方法的返回值序列化，构造返回response</li>
<li>把response传回给client</li>
<li>client接收并反序列化response，得到服务处理结果，返回给1中调用的地方，唤醒对应的客户端线程</li>
</ol>


<p>步骤1中，service代理类已经在客户端启动过程中完成注入<br/>
步骤2中，当service代理类被调用时，调用相关的信息就会被传递给启动阶段所说的InvocationHandler，即ServicePorxy的invoke方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">ServiceProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//步骤3，应该是从注册中心拉到的可提供服务的服务器列表中根据负载均衡规则选出一个，此版本上的实现暂以常量设置</span>
</span><span class='line'>        <span class="n">ProviderInfo</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">ServiceProviderManager</span><span class="o">.</span><span class="na">getProvider</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//步骤4，构造远程调用的request</span>
</span><span class='line'>        <span class="n">RemoteRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteRequest</span><span class="o">();</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setRequestId</span><span class="o">(</span><span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setServiceName</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setMethodName</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setParameterTypes</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//步骤5</span>
</span><span class='line'>        <span class="n">RemoteClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteClient</span><span class="o">(</span><span class="n">provider</span><span class="o">);</span>
</span><span class='line'>        <span class="n">RemoteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">getResponseValue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤4中，网络之间请求和响应的设计如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceRequest</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">requestId</span><span class="o">;</span> <span class="c1">//可代表一次请求的唯一编号</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceName</span><span class="o">;</span> <span class="c1">//调用的服务名</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">methodName</span><span class="o">;</span> <span class="c1">//调用的函数名</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">parameterTypes</span><span class="o">;</span> <span class="c1">//调用的函数的参数的类型</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">parameters</span><span class="o">;</span> <span class="c1">//调用函数传递的参数</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceResponse</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">requestId</span><span class="o">;</span> <span class="c1">//唯一请求的编号</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">responseCode</span><span class="o">;</span> <span class="c1">//代表返回值是否正常的结果码，比如可定义200为正常，500为异常</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">responseValue</span><span class="o">;</span> <span class="c1">//返回的结果</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤5中，客户端找到了对应的服务端机器，需要发起netty连接服务端、序列化request、发送请求、线程挂起</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">RemoteResponse</span> <span class="nf">send</span><span class="o">(</span><span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">TimeoutException</span><span class="o">,</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">SettableFuture</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//➀启动netty连接</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">bossGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Bootstrap</span> <span class="n">bootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Bootstrap</span><span class="o">();</span>
</span><span class='line'>        <span class="n">bootstrap</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossGroup</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="n">NioSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">handler</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelInitializer</span><span class="o">&lt;</span><span class="n">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>                    <span class="nd">@Override</span>
</span><span class='line'>                    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                    <span class="c1">//➃处理我们业务逻辑的ChannelHandler</span>
</span><span class='line'>                        <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">future</span><span class="o">));</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>                <span class="o">});</span>
</span><span class='line'>        <span class="c1">//➁连接到netty服务端</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bootstrap</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">providerInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">(),</span> <span class="n">providerInfo</span><span class="o">.</span><span class="na">getPort</span><span class="o">()).</span><span class="na">sync</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//➂发送request</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">writeFuture</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">bossGroup</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>➀在客户端启动netty，与服务端不同，只需要一个group，之后进行一系列的配置<br/>
➁调用bootstrap.connect连接目标netty服务器➂<br/>
➂连接成功后，writeAndFlush发送请求<br/>
➃前面提到了netty中的业务逻辑都是在ChannelHandler中实现，ChannelHandler分为Inbound和Outbound两类，Inbound会在数据传入当前服务器时进行处理，Outbound在当前服务器发送数据时进行处理，在这里使用到NettyDecoder，NettyEncoder和NettyClientHandler三个类，其中NettyDecoder和NettyClientHandler属于InboundHandler，NettyEncoder为OutBoundHandler，所以在➂处writeAndFlush发送请求后，request会经过OutboundHandler的处理，这里对应的就是NettyEncoder，在NettyEncoder中完成序列化的工作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyEncoder</span> <span class="kd">extends</span> <span class="n">MessageToByteEncoder</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">encode</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">Object</span> <span class="n">msg</span><span class="o">,</span> <span class="n">ByteBuf</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//序列化</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">Serializer</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//先写入数据的长度</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">bytes</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//写入要传输数据的字节流</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Serializer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ByteArrayOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ByteArrayOutputStream</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Hessian2Output</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Hessian2Output</span><span class="o">(</span><span class="n">bos</span><span class="o">);</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">bos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">deserialize</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ByteArrayInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Hessian2Input</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Hessian2Input</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Serializer.serialize中使用hession完成Object到字节流的转换，而Encoder中在写入这部分字节流之前，先将数据的长度写入，以供之后数据的接收端校验是否接收到了完成的数据。</p>

<p>步骤6 服务端收到字节流，需要在接收完整后进行反序列化 <br/>
对于此时接收数据的服务端来说，收到的数据由服务端启动时配置的InboundHandler来处理，在1.2 服务端启动阶段可以看到，即对应NettyDecoder和NettyServerHandler。</p>

<p>关于NettyDecoder，<a href="http://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-11">Netty UserGuide-基于流的传输</a>中的提到，在TCP/IP使用这种基于流传输的协议时，收到的数据会被存入一个buffer中，而这个buffer并不是数据包的buffer，而是字节的buffer，也就是说你的系统可能接收到这样的三个数据包： <br/>
<img src="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt="系统收到的数据包" /> <br/>
而你的应用收到字节片段很可能是这样的： <br/>
<img src="https://camo.githubusercontent.com/5b595baf5071bf669f81d08b7554064f4142cc69/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f6233316330626437626266633639666438326436" alt="应用收到的字节片段" /> <br/>
对于这个问题，需要在新的字节数据放入buffer时检测一下是否符合我们期望的长度：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyDecoder</span> <span class="kd">extends</span> <span class="n">ByteToMessageDecoder</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//每当有新的字节接收到时，decode就会被调用</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">decode</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">ByteBuf</span> <span class="n">in</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//收到的字节还不足一个int，即Encode阶段写入的数据总长度，先不处理</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;no enough readable bytes&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//此时收到的字节达到4个字节，提取一个int，即期望接收的数据总长度</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">dataLength</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">dataLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//接收的字节流除去int剩余的字节长度还未达到期望的长度，表示数据未接收完整</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">dataLength</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">in</span><span class="o">.</span><span class="na">resetReaderIndex</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//长度达到了，已经足够，读取出完整的数据</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">dataLength</span><span class="o">];</span>
</span><span class='line'>        <span class="n">in</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//把完整的数据反序列化为对象</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">deserialized</span> <span class="o">=</span> <span class="n">Serializer</span><span class="o">.</span><span class="na">deserialize</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//当decode中把一个对象加入到out中，代表已经解析成功了，之后decode不再被调用</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">deserialized</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤7、8、9： request完成了反序列化，就会被传递给下一个ChannelInboundHandler，即服务端的NettyServerHandler</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyServerHandler</span> <span class="kd">extends</span> <span class="n">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">RemoteRequest</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">channelRead0</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//收到了request，从启动时加载好的map中找到request请求中的serviceImpl实例</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">actualServiceImpl</span> <span class="o">=</span> <span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">getActualServiceImpl</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getServiceName</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">actualServiceImpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//根据request中的方法名，参数类型，参数等信息，反射调用serviceImpl</span>
</span><span class='line'>            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">serviceInterface</span> <span class="o">=</span> <span class="n">actualServiceImpl</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</span><span class='line'>            <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">serviceInterface</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">(),</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">());</span>
</span><span class='line'>            <span class="c1">//反射计算得到结果</span>
</span><span class='line'>            <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">actualServiceImpl</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getArguments</span><span class="o">());</span>
</span><span class='line'>            <span class="c1">//构造response</span>
</span><span class='line'>            <span class="n">RemoteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteResponse</span><span class="o">();</span>
</span><span class='line'>            <span class="n">response</span><span class="o">.</span><span class="na">setRequestId</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestId</span><span class="o">());</span>
</span><span class='line'>            <span class="n">response</span><span class="o">.</span><span class="na">setResponseValue</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">//向客户端返回构造完成的response</span>
</span><span class='line'>            <span class="n">ctx</span><span class="o">.</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="n">response</span><span class="o">).</span><span class="na">addListener</span><span class="o">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="na">CLOSE</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>服务端发送给客户端时，response经过NettyEncoder进行序列化。</p>

<p>这里的method的反射调用，即服务端的业务逻辑，是跑在workerEventLoopGroup线程池的线程中，但是如果业务逻辑中涉及到一些连接数据库、远程连接等耗时操作，建议新开线程池来执行，执行完成后再调用netty返回response，而让netty线程池专注处理网络通讯。</p>

<p>步骤10 客户端收到返回的response，经历NettyDecoder反序列化后，交给NettyClientHandler处理，这里有一个问题：netty的网络操作都是异步的，但是客户端代码调用时一般都需要同步的得到结果，就会涉及到一个异步转同步的机制。 <br/>
客户端发出请求后，要拿到结果，但是结果返回之前需要先挂起线程，拿到结果后再唤醒线程，是类似一个Future，原理如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ResponseFuture</span><span class="o">{</span>
</span><span class='line'>    <span class="c1">//默认future没有完成，result为空</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">completed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果未完成时来get，就会一直wait下去</span>
</span><span class='line'>        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
</span><span class='line'>            <span class="c1">//直到set被调用，标记Future为完成，线程被唤醒，返回result</span>
</span><span class='line'>            <span class="k">while</span><span class="o">(!</span><span class="n">completed</span><span class="o">){</span>
</span><span class='line'>                <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//当接收到返回的response时，设置任务完成，通知挂起的线程</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Object</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">completed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码只是为了说明原理，真实情况不会这么简单，一些异常的情况会导致线程一直挂起而无法唤醒，需要添加超时机制来防止这种状况的发生，我直接使用了guava框架的SettableFuture，其get方法可以传入timeout时间，set方法来标记Future得到结果，内部实现实际使用了AbstractQueuedSynchronizer，但原理是基本一致的。</p>

<p>先再回顾一下客户端在发送请求的片段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">RemoteResponse</span> <span class="nf">send</span><span class="o">(</span><span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">){</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">SettableFuture</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//启动netty连接</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="c1">//添加ChannelHandler</span>
</span><span class='line'>    <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">future</span><span class="o">));</span>
</span><span class='line'>    <span class="c1">//连接到netty服务端，发送请求</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="c1">//调用future拿结果，得到结果之前挂起</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在发送之前创建一个Response的SettableFuture，创建连接时作为NettyClientHandler的成员变量，发送请求之后，调用future.get，在得到response之前，挂起线程；<br/>
在接收到response，反序列化后，reponse交给NettyClientHandler：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyClientHandler</span> <span class="kd">extends</span> <span class="n">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">future</span> <span class="o">=</span> <span class="n">future</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">channelRead0</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">RemoteResponse</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">future</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用future.set设置response，唤醒线程，把response的结果返回给代码调用处，一次rpc框架的调用就完成了。</p>

<h1>测试程序</h1>

<p>此版本提供rpc框架的本地测试程序，在zing-demo模块的test目录下，模拟了一个DemoService的接口的调用：
1.  先运行DemoServerTest的main函数，会在本地以8080端口启动netty服务。
2.  再运行DemoClientTest会以rpc的方式发起请求，分别有单次的简单参数请求、复杂类型的请求、线程池模拟批量请求等。</p>

<h1>总结</h1>

<p>这个版本主要目标是实现RPC框架的联通，演示其中一些关键点的实现，其中很多地方有优化的空间，比如客户端连接可以重用，服务端业务逻辑在新的线程池中执行，还有下一次会实现的服务注册中心功能等，之后会逐步进行完善。
如果对大家对文章有任何疑问或建议，欢迎指正，共同讨论。</p>

<blockquote><p>文章欢迎转载，但转载时请保留本段文字，并置于文章的顶部
作者：赵轩辰
本文原文地址：<a href="http://zxcpro.github.io/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/">http://zxcpro.github.io/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/</a></p></blockquote>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-01-06T22:05:15+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/zhong-jian-jian-rpc/'>中间件,rpc</a>


</div>
	
	<div class="comments"><a href="#disqus_thread">Comments</a></div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>


</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    xuanchen.zhao

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zxcgitblog';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://zxcpro.github.io/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/';
        var disqus_url = 'http://zxcpro.github.io/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-69206979-1']);
		_gaq.push(['_setDomainName','github.io']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>