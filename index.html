
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>xuanchen&#8217;s Blog</title>
	<meta name="author" content="xuanchen.zhao">

	
	<meta name="description" content="前言 在上一篇文章"从零开始实现RPC框架&ndash;(1)基本原理&ldquo;中，大致讲述了RPC框架的原理、可能遇到的问题及一些解决的方案。
之后我实现了RPC框架的基础功能&ndash;客户端和服务端之间的调用，代码已经上传至github（项目链接）。 这个版本tag名为" &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="xuanchen's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">xuanchen&#8217;s Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:zxcpro.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:zxcpro.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/">
		
			从零开始实现RPC框架&#8211;(2)实现RPC调用</a>
	</h2>
	<div class="entry-content">
		<h1>前言</h1>

<p>在上一篇文章&#8221;<a href="http://zxcpro.github.io/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">从零开始实现RPC框架&ndash;(1)基本原理</a>&ldquo;中，大致讲述了RPC框架的原理、可能遇到的问题及一些解决的方案。<br/>
之后我实现了RPC框架的基础功能&ndash;客户端和服务端之间的调用，代码已经上传至github（<a href="https://github.com/zxcpro/zing">项目链接</a>）。  <br/>
这个版本tag名为&#8221;getting-through&#8221;，目前客户端选择服务端地址时暂时以常量形式设置，服务注册发现和负载均衡的特性会在下一个版本完成，本次主要功能放在客户端和服务端之间的调用过程的实现上。</p>

<h1>PRC调用的实现</h1>

<p>RPC框架主要可以分为启动和服务调用两个阶段，下面分阶段分别来看客户端和服务端的实现：</p>

<h2>1.启动阶段</h2>

<h3>1.1 客户端启动&ndash;初始化代理类</h3>

<h4>像本地方法一样调用</h4>

<p>客户端在启动时，需要为客户端所依赖的各个service生成各自的proxy bean，并且借助spring在启动时注入到对应的业务组件中，proxy bean应该拥有和service完全相同的接口，来接管所有对service的方法调用</p>

<p>以一个sayHello例子为例，程序很简单，客户端告知我是“zxc”，服务端返回”Hello zxc!”：</p>

<p>HelloService接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">HelloService</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实现类HelloServiceImpl：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloServiceImpl</span> <span class="kd">implements</span> <span class="n">HelloService</span> <span class="o">{</span>
</span><span class='line'>     <span class="kd">public</span> <span class="n">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="err">“</span><span class="n">Hello</span> <span class="err">&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在进行远程调用的时候，把HelloService接口作为api的一部分，单独打jar包，再由客户端应用引用。</p>

<p>我们的目标要达到的效果是能够在客户端代码中自然的进行调用，效果如代码所示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SomeClientBiz</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Autowired</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">HelloService</span> <span class="n">helloService</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doSomething</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">reply</span> <span class="o">=</span> <span class="n">helloService</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="s">&quot;zxc&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里注入的service bean并不是HelloServiceImpl，因为HelloServiceImpl并不在客户端上，这个bean只是实现了HelloService接口的动态代理类，在调用时其真正的行为是发起一次rpc调用。</p>

<h4>代理类的实现方法</h4>

<p>代理类可以利用JDK中的动态代理方式来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Object</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">Proxy</span><span class="o">.</span><span class="na">newProxyInstance</span><span class="o">(</span><span class="n">classLoader</span><span class="o">,</span> <span class="n">interfaceClassList</span><span class="o">,</span> <span class="n">invocationHandler</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个参数是classLoader <br/>
第二个参数是要代理的接口的class的list，事例中是只有一个元素即HelloService.class的list<br/>
第三个参数是InvocationHandler，代理类的主逻辑就在这里，需要实现其invoke接口：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">ServiceProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//proxy logic here</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里invoke接口参数中，obj参数就是之前newProxyInstance所返回的proxy，在客户端调用的那个对象；method就是调用的方法，在例子中就是sayHello方法；arguments是此次调用所传入的参数队列，在例子中是String类型的&#8221;zxc&#8221;。</p>

<p>这样就得到一个有着HelloService接口的代理类，这个类上任何方法的调用都会被传递给内部实现了InvocationHanlder接口的代理来处理</p>

<p>PS： <br/>
google的guava框架对动态代理相关类Proxy.newProxyInstance和InvocationHandler也有对应的封装，分别是Reflection.newProxy和AbstractInvocationHandler：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">//隐藏了classLoader的逻辑，并且支持泛型，也就是直接返回HelloService类型的对象</span>
</span><span class='line'><span class="n">HelloService</span> <span class="n">service</span> <span class="o">=</span> <span class="n">Reflection</span><span class="o">.</span><span class="na">newProxy</span><span class="o">(</span><span class="n">serviceClass</span><span class="o">,</span> <span class="n">invocationHandler</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">AbstractInvocationHandler</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">proxy</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//先排除 hashCode,equals,toString 的调用</span>
</span><span class='line'>        <span class="c1">//只将有意义的调用传递给handlerInvocation方法</span>
</span><span class='line'>        <span class="n">handleInvocation</span><span class="o">(</span><span class="n">proxy</span><span class="o">,</span> <span class="n">method</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>让代码更加简单优雅。</p>

<h4>让spring管理代理类的生命周期</h4>

<p>代理类需要spring来管理其生命周期，才能完成代理类到业务Biz的注入，定义代理类的bean：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.client.proxy.ServiceProxyBeanFactory&quot;</span> <span class="n">factory</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;getService&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">constructor</span><span class="o">-</span><span class="n">arg</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.api.HelloService&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>ServiceProxyBeanFactory是代理的工厂类，getService是工厂方法，而生成代理bean的参数，目前为止，只需要一个类的全名，以得到对应的class来生成代理类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceProxyBeanFactory</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">ClassNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">serviceClass</span> <span class="o">=</span> <span class="n">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Reflection</span><span class="o">.</span><span class="na">newProxy</span><span class="o">(</span><span class="n">serviceClass</span><span class="o">,</span> <span class="k">new</span> <span class="nf">ServiceProxy</span><span class="o">(</span><span class="n">serviceName</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，启动阶段客户端的初始化就完成了，这些被注入到客户端业务逻辑中的代理配在之后调用阶段就会派上用场。</p>

<h3>1.2 服务端启动&ndash;加载service接口到实现的映射并启动netty</h3>

<h4>加载service接口到实现类映射</h4>

<p>在服务端，我们有接口HelloService及其实现类HelloServiceImpl，要保证在rpc请求到来时能找到要请求服务对应的实现逻辑，就需要在服务启动之时在内存中维护好这个映射。</p>

<p>还是借助spring定义这些bean：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.service.impl.HelloServiceImpl&quot;</span> <span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">bean</span> <span class="n">class</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.server.remote.RemoteServiceBean&quot;</span> <span class="n">init</span><span class="o">-</span><span class="n">method</span><span class="o">=</span><span class="s">&quot;init&quot;</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;serviceName&quot;</span> <span class="n">value</span><span class="o">=</span><span class="s">&quot;org.zxc.zing.demo.api.HelloService&quot;</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">property</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;serviceImpl&quot;</span> <span class="n">ref</span><span class="o">=</span><span class="s">&quot;helloService&quot;</span><span class="o">/&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">bean</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>RemoteServiceBean中有两个参数，serviceName即之前和客户端统一的服务接口类的全名，serviceImpl即服务接口对应的服务实现类。<br/>
我们把这个映射用一个静态类的静态成员Map&lt;String, Object>的方式维护在内存中，并且在spring加载这个bean的时候执行init方法，把当前的Impl加入Map。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceBean</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceName</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">addService</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceServer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">serviceImplMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">,</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然目前只有spring加载bean初始化时串行的进行add，但之后可能涉及到一些场景在其它时机对map进行增删，比如管理服务时需要停止/恢复提供某个service，先用一个ConcurrentHashMap来保证线程安全。</p>

<p>随着spring bean一个个加载完成，服务接口到实现类的映射也就加载完毕了。</p>

<p>可以看到，在addService之前还有一个startup方法，即启动netty服务，下面就来看看netty服务的启动。</p>

<h4>启动netty服务</h4>

<p>之前说rpc服务端启动时需要加载服务映射和启动netty服务两件事，先后顺序是怎样的呢？ <br/>
考虑到之后有了服务注册中心，服务端加载完service bean的时候要告知注册中心这台服务器可以提供该service的服务，这样客户端就能拿到这台服务端的地址从而发送请求，期望请求到来之时服务端应该是已经启动好的，也就是说启动netty服务最好在加载service bean之前完成。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RemoteServiceServer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="kt">boolean</span> <span class="n">started</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">serviceImplMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">bootstrap</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">addService</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">,</span> <span class="n">Object</span> <span class="n">serviceImpl</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">serviceName</span><span class="o">,</span> <span class="n">serviceImpl</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bootstrap</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">doStartup</span><span class="o">();</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doStartup</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//netty bootstrap</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">getActualServiceImpl</span><span class="o">(</span><span class="n">String</span> <span class="n">serviceName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(!</span><span class="n">started</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">log</span><span class="o">.</span><span class="na">warn</span><span class="o">(</span><span class="s">&quot;server not started&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="n">bootstrap</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;cur map when get:&quot;</span><span class="o">+</span><span class="n">serviceImplMap</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">serviceImplMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在RemoteServiceServer的静态块中执行启动，当spring加载第一个RemoteServiceBean并执行其init方法时，RemoteServiceServer.addService时JVM加载RemoteServiceServer类，进而执行启动bootstrap流程。<br/>
除去服务端第一次启动时需要执行bootstrap之外，考虑到后续可能在某些情况下，比如初始化启动失败，在请求到来时发现服务未能启动成功而重试启动等，用volatile的started标志位加上double-check的方式对bootstrap做一个并发的控制以保证线程安全。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">doStart</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">bossGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">workerGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ServerBootstrap</span> <span class="n">bootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ServerBootstrap</span><span class="o">();</span>
</span><span class='line'>    <span class="n">bootstrap</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossGroup</span><span class="o">,</span> <span class="n">workerGroup</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="n">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelInitializer</span><span class="o">&lt;</span><span class="n">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>                <span class="nd">@Override</span>
</span><span class='line'>                <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyServerHandler</span><span class="o">());</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}).</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>
</span><span class='line'>            <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bootstrap</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="mi">8080</span><span class="o">).</span><span class="na">sync</span><span class="o">();</span>
</span><span class='line'>        <span class="n">f</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ChannelFutureListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="nd">@Override</span>
</span><span class='line'>            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">operationComplete</span><span class="o">(</span><span class="n">ChannelFuture</span> <span class="n">future</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">isSuccess</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">started</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>                    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;server started!&quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">});</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;server started failed:&quot;</span><span class="o">+</span><span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">(),</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>doStart中调用netty的api进行启动： <br/>
EventLoop可以理解为类似守护进程，不断处理到来的请求，这里定义了一个bossGroup，一个workerGroup，bossGroup接收请求后分发给workerGroup，workerGroup在自己的线程池中处理这些请求。 <br/>
数据到达当前机器，服务端进行逻辑处理，处理完成的数据传输回去这些逻辑都是依赖ChannelHandler来实现，代码中我们定义的NettyDecoder，NettyEncoder，NettyServerHandler都是ChannelHandler，具体的机制在调用阶段详述。</p>

<p>PS：
netty是一个nio的通讯框架，屏蔽了很多的底层网络细节，api封装的简单易用，对netty不太了解的同学，可以参考<a href="http://netty.io/wiki/user-guide.html">官方UserGuide</a>，netty 3.x/4.x/5.x版本api有较大的差异，本项目依赖的是4.0.32版本。</p>

<p>这样，客户端完成了服务代理类的注入，服务端启动了netty并加载了service对应的实现，一切就绪等待RPC调用开始。</p>

<h2>2.调用阶段</h2>

<p><a href="http://zxcpro.github.io/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">上一篇文章</a>中主要描述了一次RPC调用的过程，为了读起来方便，这里再引用一遍： <br/>
<img src="/assets/img/rpc/rpcflow.png" alt="RPC调用流程" /></p>

<ol>
<li>客户端调用了某个服务的某个方法，期望得到处理的结果</li>
<li>把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</li>
<li>根据被调用的服务名，方法签名等信息找到可以提供服务的server列表</li>
<li>根据负载均衡的规则，选出其中一个server作为目标来调用</li>
<li>向选出的server发送该请求，客户端线程挂起</li>
<li>server接收到请求，反序列并解析得到对应的服务名，方法签名，参数信息</li>
<li>server根据调用信息找到真正的业务服务实例，调用业务服务该方法</li>
<li>把方法的返回值序列化，构造返回response</li>
<li>把response传回给client</li>
<li>client接收并反序列化response，得到服务处理结果，返回给1中调用的地方，唤醒对应的客户端线程</li>
</ol>


<p>步骤1中，service代理类已经在客户端启动过程中完成注入<br/>
步骤2中，当service代理类被调用时，调用相关的信息就会被传递给启动阶段所说的InvocationHandler，即ServicePorxy的invoke方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">ServiceProxy</span> <span class="kd">implements</span> <span class="n">InvocationHandler</span> <span class="o">{</span>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">,</span> <span class="n">Method</span> <span class="n">method</span><span class="o">,</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">arguments</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//步骤3，应该是从注册中心拉到的可提供服务的服务器列表中根据负载均衡规则选出一个，此版本上的实现暂以常量设置</span>
</span><span class='line'>        <span class="n">ProviderInfo</span> <span class="n">provider</span> <span class="o">=</span> <span class="n">ServiceProviderManager</span><span class="o">.</span><span class="na">getProvider</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//步骤4，构造远程调用的request</span>
</span><span class='line'>        <span class="n">RemoteRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteRequest</span><span class="o">();</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setRequestId</span><span class="o">(</span><span class="n">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setServiceName</span><span class="o">(</span><span class="n">serviceName</span><span class="o">);</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setMethodName</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setParameterTypes</span><span class="o">(</span><span class="n">method</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">());</span>
</span><span class='line'>        <span class="n">request</span><span class="o">.</span><span class="na">setArguments</span><span class="o">(</span><span class="n">args</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//步骤5</span>
</span><span class='line'>        <span class="n">RemoteClient</span> <span class="n">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteClient</span><span class="o">(</span><span class="n">provider</span><span class="o">);</span>
</span><span class='line'>        <span class="n">RemoteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">response</span><span class="o">.</span><span class="na">getResponseValue</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤4中，网络之间请求和响应的设计如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceRequest</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">requestId</span><span class="o">;</span> <span class="c1">//可代表一次请求的唯一编号</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceName</span><span class="o">;</span> <span class="c1">//调用的服务名</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">methodName</span><span class="o">;</span> <span class="c1">//调用的函数名</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Class</span><span class="o">&lt;?&gt;[]</span> <span class="n">parameterTypes</span><span class="o">;</span> <span class="c1">//调用的函数的参数的类型</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span><span class="o">[]</span> <span class="n">parameters</span><span class="o">;</span> <span class="c1">//调用函数传递的参数</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceResponse</span><span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">requestId</span><span class="o">;</span> <span class="c1">//唯一请求的编号</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">responseCode</span><span class="o">;</span> <span class="c1">//代表返回值是否正常的结果码，比如可定义200为正常，500为异常</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">responseValue</span><span class="o">;</span> <span class="c1">//返回的结果</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤5中，客户端找到了对应的服务端机器，需要发起netty连接服务端、序列化request、发送请求、线程挂起</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">RemoteResponse</span> <span class="nf">send</span><span class="o">(</span><span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">TimeoutException</span><span class="o">,</span> <span class="n">ExecutionException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">SettableFuture</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//➀启动netty连接</span>
</span><span class='line'>    <span class="n">EventLoopGroup</span> <span class="n">bossGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">NioEventLoopGroup</span><span class="o">();</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Bootstrap</span> <span class="n">bootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Bootstrap</span><span class="o">();</span>
</span><span class='line'>        <span class="n">bootstrap</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossGroup</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="n">NioSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="n">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">handler</span><span class="o">(</span><span class="k">new</span> <span class="n">ChannelInitializer</span><span class="o">&lt;</span><span class="n">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
</span><span class='line'>                    <span class="nd">@Override</span>
</span><span class='line'>                    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="n">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>                    <span class="c1">//➃处理我们业务逻辑的ChannelHandler</span>
</span><span class='line'>                        <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">future</span><span class="o">));</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>                <span class="o">});</span>
</span><span class='line'>        <span class="c1">//➁连接到netty服务端</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">bootstrap</span><span class="o">.</span><span class="na">connect</span><span class="o">(</span><span class="n">providerInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">(),</span> <span class="n">providerInfo</span><span class="o">.</span><span class="na">getPort</span><span class="o">()).</span><span class="na">sync</span><span class="o">();</span>
</span><span class='line'>        <span class="c1">//➂发送request</span>
</span><span class='line'>        <span class="n">ChannelFuture</span> <span class="n">writeFuture</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="n">request</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">bossGroup</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>➀在客户端启动netty，与服务端不同，只需要一个group，之后进行一系列的配置<br/>
➁调用bootstrap.connect连接目标netty服务器➂<br/>
➂连接成功后，writeAndFlush发送请求<br/>
➃前面提到了netty中的业务逻辑都是在ChannelHandler中实现，ChannelHandler分为Inbound和Outbound两类，Inbound会在数据传入当前服务器时进行处理，Outbound在当前服务器发送数据时进行处理，在这里使用到NettyDecoder，NettyEncoder和NettyClientHandler三个类，其中NettyDecoder和NettyClientHandler属于InboundHandler，NettyEncoder为OutBoundHandler，所以在➂处writeAndFlush发送请求后，request会经过OutboundHandler的处理，这里对应的就是NettyEncoder，在NettyEncoder中完成序列化的工作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyEncoder</span> <span class="kd">extends</span> <span class="n">MessageToByteEncoder</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">encode</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">Object</span> <span class="n">msg</span><span class="o">,</span> <span class="n">ByteBuf</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">//序列化</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">Serializer</span><span class="o">.</span><span class="na">serialize</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//先写入数据的长度</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">bytes</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//写入要传输数据的字节流</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Serializer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">serialize</span><span class="o">(</span><span class="n">Object</span> <span class="n">obj</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ByteArrayOutputStream</span> <span class="n">bos</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ByteArrayOutputStream</span><span class="o">();</span>
</span><span class='line'>        <span class="n">Hessian2Output</span> <span class="n">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Hessian2Output</span><span class="o">(</span><span class="n">bos</span><span class="o">);</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">writeObject</span><span class="o">(</span><span class="n">obj</span><span class="o">);</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">bos</span><span class="o">.</span><span class="na">toByteArray</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="n">Object</span> <span class="nf">deserialize</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">ByteArrayInputStream</span> <span class="n">bis</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ByteArrayInputStream</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Hessian2Input</span> <span class="n">in</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Hessian2Input</span><span class="o">(</span><span class="n">bis</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">in</span><span class="o">.</span><span class="na">readObject</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Serializer.serialize中使用hession完成Object到字节流的转换，而Encoder中在写入这部分字节流之前，先将数据的长度写入，以供之后数据的接收端校验是否接收到了完成的数据。</p>

<p>步骤6 服务端收到字节流，需要在接收完整后进行反序列化 <br/>
对于此时接收数据的服务端来说，收到的数据由服务端启动时配置的InboundHandler来处理，在1.2 服务端启动阶段可以看到，即对应NettyDecoder和NettyServerHandler。</p>

<p>关于NettyDecoder，<a href="http://netty.io/wiki/user-guide-for-4.x.html#wiki-h3-11">Netty UserGuide-基于流的传输</a>中的提到，在TCP/IP使用这种基于流传输的协议时，收到的数据会被存入一个buffer中，而这个buffer并不是数据包的buffer，而是字节的buffer，也就是说你的系统可能接收到这样的三个数据包： <br/>
<img src="https://camo.githubusercontent.com/24ed1176ecca468dfb2b8b017bb927a8715a16f2/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f3832653366626530653264346466323833323262" alt="系统收到的数据包" /> <br/>
而你的应用收到字节片段很可能是这样的： <br/>
<img src="https://camo.githubusercontent.com/5b595baf5071bf669f81d08b7554064f4142cc69/687474703a2f2f756d6c2e6d766e7365617263682e6f72672f676973742f6233316330626437626266633639666438326436" alt="应用收到的字节片段" /> <br/>
对于这个问题，需要在新的字节数据放入buffer时检测一下是否符合我们期望的长度：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyDecoder</span> <span class="kd">extends</span> <span class="n">ByteToMessageDecoder</span><span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//每当有新的字节接收到时，decode就会被调用</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">decode</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">ByteBuf</span> <span class="n">in</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">out</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//收到的字节还不足一个int，即Encode阶段写入的数据总长度，先不处理</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;no enough readable bytes&quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//此时收到的字节达到4个字节，提取一个int，即期望接收的数据总长度</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">dataLength</span> <span class="o">=</span> <span class="n">in</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">dataLength</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//接收的字节流除去int剩余的字节长度还未达到期望的长度，表示数据未接收完整</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">dataLength</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">in</span><span class="o">.</span><span class="na">resetReaderIndex</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//长度达到了，已经足够，读取出完整的数据</span>
</span><span class='line'>        <span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">dataLength</span><span class="o">];</span>
</span><span class='line'>        <span class="n">in</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//把完整的数据反序列化为对象</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">deserialized</span> <span class="o">=</span> <span class="n">Serializer</span><span class="o">.</span><span class="na">deserialize</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
</span><span class='line'>        <span class="c1">//当decode中把一个对象加入到out中，代表已经解析成功了，之后decode不再被调用</span>
</span><span class='line'>        <span class="n">out</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">deserialized</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>步骤7、8、9： request完成了反序列化，就会被传递给下一个ChannelInboundHandler，即服务端的NettyServerHandler</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyServerHandler</span> <span class="kd">extends</span> <span class="n">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">RemoteRequest</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">channelRead0</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//收到了request，从启动时加载好的map中找到request请求中的serviceImpl实例</span>
</span><span class='line'>        <span class="n">Object</span> <span class="n">actualServiceImpl</span> <span class="o">=</span> <span class="n">RemoteServiceServer</span><span class="o">.</span><span class="na">getActualServiceImpl</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getServiceName</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">actualServiceImpl</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//根据request中的方法名，参数类型，参数等信息，反射调用serviceImpl</span>
</span><span class='line'>            <span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">serviceInterface</span> <span class="o">=</span> <span class="n">actualServiceImpl</span><span class="o">.</span><span class="na">getClass</span><span class="o">();</span>
</span><span class='line'>            <span class="n">Method</span> <span class="n">method</span> <span class="o">=</span> <span class="n">serviceInterface</span><span class="o">.</span><span class="na">getMethod</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getMethodName</span><span class="o">(),</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameterTypes</span><span class="o">());</span>
</span><span class='line'>            <span class="c1">//反射计算得到结果</span>
</span><span class='line'>            <span class="n">Object</span> <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">actualServiceImpl</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">getArguments</span><span class="o">());</span>
</span><span class='line'>            <span class="c1">//构造response</span>
</span><span class='line'>            <span class="n">RemoteResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RemoteResponse</span><span class="o">();</span>
</span><span class='line'>            <span class="n">response</span><span class="o">.</span><span class="na">setRequestId</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getRequestId</span><span class="o">());</span>
</span><span class='line'>            <span class="n">response</span><span class="o">.</span><span class="na">setResponseValue</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>
</span><span class='line'>            <span class="c1">//向客户端返回构造完成的response</span>
</span><span class='line'>            <span class="n">ctx</span><span class="o">.</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="n">response</span><span class="o">).</span><span class="na">addListener</span><span class="o">(</span><span class="n">ChannelFutureListener</span><span class="o">.</span><span class="na">CLOSE</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>服务端发送给客户端时，response经过NettyEncoder进行序列化。</p>

<p>这里的method的反射调用，即服务端的业务逻辑，是跑在workerEventLoopGroup线程池的线程中，但是如果业务逻辑中涉及到一些连接数据库、远程连接等耗时操作，建议新开线程池来执行，执行完成后再调用netty返回response，而让netty线程池专注处理网络通讯。</p>

<p>步骤10 客户端收到返回的response，经历NettyDecoder反序列化后，交给NettyClientHandler处理，这里有一个问题：netty的网络操作都是异步的，但是客户端代码调用时一般都需要同步的得到结果，就会涉及到一个异步转同步的机制。 <br/>
客户端发出请求后，要拿到结果，但是结果返回之前需要先挂起线程，拿到结果后再唤醒线程，是类似一个Future，原理如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ResponseFuture</span><span class="o">{</span>
</span><span class='line'>    <span class="c1">//默认future没有完成，result为空</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">completed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Object</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//如果未完成时来get，就会一直wait下去</span>
</span><span class='line'>        <span class="kd">synchronized</span><span class="o">(</span><span class="k">this</span><span class="o">){</span>
</span><span class='line'>            <span class="c1">//直到set被调用，标记Future为完成，线程被唤醒，返回result</span>
</span><span class='line'>            <span class="k">while</span><span class="o">(!</span><span class="n">completed</span><span class="o">){</span>
</span><span class='line'>                <span class="k">this</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">//当接收到返回的response时，设置任务完成，通知挂起的线程</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="n">Object</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">completed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码只是为了说明原理，真实情况不会这么简单，一些异常的情况会导致线程一直挂起而无法唤醒，需要添加超时机制来防止这种状况的发生，我直接使用了guava框架的SettableFuture，其get方法可以传入timeout时间，set方法来标记Future得到结果，内部实现实际使用了AbstractQueuedSynchronizer，但原理是基本一致的。</p>

<p>先再回顾一下客户端在发送请求的片段：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">RemoteResponse</span> <span class="nf">send</span><span class="o">(</span><span class="n">RemoteRequest</span> <span class="n">request</span><span class="o">){</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">SettableFuture</span><span class="o">.</span><span class="na">create</span><span class="o">();</span>
</span><span class='line'>    <span class="c1">//启动netty连接</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="c1">//添加ChannelHandler</span>
</span><span class='line'>    <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nf">NettyDecoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyEncoder</span><span class="o">(),</span> <span class="k">new</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">future</span><span class="o">));</span>
</span><span class='line'>    <span class="c1">//连接到netty服务端，发送请求</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="c1">//调用future拿结果，得到结果之前挂起</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">future</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1000</span><span class="o">,</span> <span class="n">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在发送之前创建一个Response的SettableFuture，创建连接时作为NettyClientHandler的成员变量，发送请求之后，调用future.get，在得到response之前，挂起线程；<br/>
在接收到response，反序列化后，reponse交给NettyClientHandler：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyClientHandler</span> <span class="kd">extends</span> <span class="n">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">NettyClientHandler</span><span class="o">(</span><span class="n">SettableFuture</span><span class="o">&lt;</span><span class="n">RemoteResponse</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">future</span> <span class="o">=</span> <span class="n">future</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">channelRead0</span><span class="o">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="n">RemoteResponse</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">future</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用future.set设置response，唤醒线程，把response的结果返回给代码调用处，一次rpc框架的调用就完成了。</p>

<h1>测试程序</h1>

<p>此版本提供rpc框架的本地测试程序，在zing-demo模块的test目录下，模拟了一个DemoService的接口的调用：
1.  先运行DemoServerTest的main函数，会在本地以8080端口启动netty服务。
2.  再运行DemoClientTest会以rpc的方式发起请求，分别有单次的简单参数请求、复杂类型的请求、线程池模拟批量请求等。</p>

<h1>总结</h1>

<p>这个版本主要目标是实现RPC框架的联通，演示其中一些关键点的实现，其中很多地方有优化的空间，比如客户端连接可以重用，服务端业务逻辑在新的线程池中执行，还有下一次会实现的服务注册中心功能等，之后会逐步进行完善。
如果对大家对文章有任何疑问或建议，欢迎指正，共同讨论。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2016-01-06T22:05:15+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/zhong-jian-jian-rpc/'>中间件,rpc</a>


</div>
	
	<div class="comments"><a href="/blog/2016/01/06/cong-ling-kai-shi-shi-xian-rpckuang-jia-2-shi-xian-rpcdiao-yong/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">
		
			从零开始实现RPC框架&#8211;(1)基本原理</a>
	</h2>
	<div class="entry-content">
		<h1>一.RPC概述</h1>

<p>RPC即是远程过程调用(Remote Procedure Call)，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。</p>

<p>现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成，分布式的应用可以借助rpc来完成机器之间的调用。</p>

<h1>二.RPC框架原理</h1>

<p>在RPC框架中主要有两个角色，client和server。一台服务器作为server向外提供服务，同时其内部又调用了其它的服务，这时它也是另外一个服务的client。</p>

<h2>1.RPC框架原理</h2>

<p>下面通过分析一下一次rpc调用的过程来大致了解RPC的原理</p>

<p><img src="/assets/img/rpc/rpcflow.png" alt="RPC调用流程" /></p>

<ol>
<li>客户端调用了某个服务的某个方法，期望得到处理的结果</li>
<li>把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</li>
<li>根据被调用的服务名，方法签名等信息找到可以提供服务的server列表</li>
<li>根据负载均衡的规则，选出其中一个server作为目标来调用</li>
<li>向选出的server发送该请求，客户端线程挂起</li>
<li>server接收到请求，反序列并解析得到对应的服务名，方法签名，参数信息</li>
<li>server根据调用信息找到真正的业务服务实例，调用业务服务该方法</li>
<li>把方法的返回值序列化，构造返回response</li>
<li>把response传回给client</li>
<li>client接收并反序列化response，得到服务处理结果，返回给1中调用的地方，唤醒对应的客户端线程</li>
</ol>


<h2>2.实现一次RPC请求要解决的问题</h2>

<p>原理并不复杂，但实现起来每一个步骤中都有需要解决的问题，对应一种或多种解决的方案，一个个来分析：</p>

<h3>1.客户端调用了某个服务的某个方法，期望得到处理的结果</h3>

<p>Q：如何自然的发起RPC调用？</p>

<p>client调用服务时希望尽量能够自然，就像在调用本地方法一样，比如要调用的服务是UserService，那么希望调用的时候也是userService.getUser(userId)这样的形式，客户端代码编写阶段就清晰的看到服务可提供的方法的签名</p>

<p>A:利用代理模式，这里需要的是一个和userService有一样接口的代理，在其方法被调用的时候执行远程请求的逻辑，以java为例，可以用JDK的动态代理代理或者AOP来实现。</p>

<h3>2.把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</h3>

<p>Q:如何进行序列化？</p>

<p>序列化其实是协议的一部分，网络一端以什么样的规则把数据对象序列化成二进制串，网络传输到了另一端后以什么样的规则解析回来。</p>

<p>A:成熟的序列化实现方式已经有很多，不需要自己来实现，比如JDK自带的序列化，jackson，hession，protostuff等，我们会根据各种序列化的速度，序列化后占用空间大小等方面来选择，详见<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">各种序列化性能比较</a>。</p>

<h3>3.根据被调用的该服务名，方法签名 找到可以提供服务的server列表</h3>

<p>Q:server列表存在哪里？</p>

<p>A:这里所说的是一个服务注册中心，在组件启动的时候可以加载当前正在提供服务的server列表，这意味注册中心需要能够存储这个列表，并且在server服务器上/下线、心跳中断/恢复时及时更新列表，并且注册中心必须保证高可用，不能由于一两台机器挂掉就变得不可用，也就是说需要集群和冗余的支持。听起来有些复杂，其实业界已经有成熟的方案了，可以选择利用zookeeper来实现，其高可用性，支持集群和冗余，pub/sub的功能都是注册中心需要的。</p>

<p>另外，除了注册中心外，client上也可以在内存中维护一份列表，启动时访问注册中心初始化，在注册中心列表变化时接收通知同步修改，这样做的好处是不用每次调用都访问注册中心。</p>

<h3>4.根据负载均衡的规则，选出其中一个server作为目标来调用</h3>

<p>Q:负载均衡由谁实现？如何实现？负载均衡的策略如何？</p>

<p>A:负载均衡可以作为独立模块，也可以直接放在客户端中，两种方案各有利弊: <br/>
独立部署的好处是客户端的职责单一，只负责调用，负载均衡模块可以根据全局的服务器状态来选择合适的server，缺点是客户端每次请求都要到负载均衡中心去请求server地址，多了一次网络请求，而且如果负载均衡中心挂了，服务就会立刻不能访问。</p>

<p>如果放在客户端上，客户端本地也维护一套注册中心的server列表，并且接收注册中心消息进行同步变更，每次就可以直接从本地的server列表中取出使用，但是这时的负载均衡策略就只能根据当前客户端调用server的情况来进行，比如当前客户端列表中有a，b，c三个server，可以轮询访问，从所有的客户端角度来看也是均衡的。</p>

<h3>5.向第4步中选出的server发送该请求，客户端线程挂起</h3>

<p>Q:如何选择网络传输协议？同步/异步IO？ <br/>
A:网络传输协议的选择，常用的一般有TCP和HTTP两种方式，TCP方式传输效率高，但是实现起来复杂，HTTP方式更通用，开发起来更简单，但是传输效率不高。
同步的发送方式是发出请求后线程阻塞等待服务处理返回，实现起来容易，但是性能会差很多，一次请求发出后，在服务端处理逻辑时，IO阻塞没有得到充分的利用。而在异步IO的情况下，请求传输到服务端时IO不阻塞，继续处理其它的数据传输，而等服务端完成逻辑计算后再来传输，系统吞吐量会大很多。但是异步IO实现起来会比较复杂，一般我们借助netty，mina等nio通讯框架实现。</p>

<h3>6.server接收到请求，反序列化并解析得到对应的服务名，方法签名，参数信息</h3>

<p>Q:如果RPC支持多种序列化方式的扩展，接收的一端如何知道用哪种方式来进行反序列化？ <br/>
A:得到二进制串之后，如果是可支持多种序列化协议的，需要我们自己做一部分的二进制串解析工作，比如我们约定第第一个字节代表选择序列化的方式，收到二进制串后先读出这个字节，选择对应的反序列化协议解析后面的字节。</p>

<h3>7.server根据调用信息找到真正的业务服务实例，调用业务服务该方法</h3>

<p>Q:如何根据服务名，函数参数找到对应的服务实例？ <br/>
A:一般的应用都会用spring来管理，比如像服务中调用服务的service，让spring来管理，组装完成之后再返回使用起来非常方便，所以我们要根据服务名从spring中找到对应的bean，这里需要借助反射从服务名到class的转换，然后同样借助反射完成方法的调用。</p>

<h3>8.把方法的返回值序列化，构造返回response</h3>

<p>序列化时也要同6中所述，把序列化方式按照同样的规则写在二进制串中。</p>

<h3>9.把response传回给client</h3>

<p>对应步骤5中选择的网络协议及通讯方式实现</p>

<h3>10.client接收并反序列化response，得到服务处理结果，返回给步骤1中调用的地方，唤醒对应的客户端线程</h3>

<p>Q:如果是异步调用，如何让客户端在调用时同步得到结果？ <br/>
A:这里涉及到一个异步转同步的问题，客户端在发出请求后，可以让当前线程等待在一个锁上，并把锁对象放在以该请求id为key的map中，而收到返回的response的回调时，根据reponse中的之前的请求Id从内存中的这个map中拿到这个锁，唤醒客户端线程，继续取走并返回的reponse。</p>

<h2>3.启动流程</h2>

<p>1.client在启动时需要从服务注册中心同步自己关心的服务的地址列表，并在服务列表发生变化时更新列表。
2.server在启动时需要向服务注册中心注册自己能够提供服务的地址和端口。
3.监控系统定时向server发送心跳请求来确认server的可用性，如果不可用通知注册中心踢出列表，重试可用后再添加等。</p>

<p>下一篇文章我们将详细分析并实现RPC框架的主流程，源码会放在git上供大家参考，如果有问题，欢迎一起讨论。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-12-10T10:53:30+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/zhong-jian-jian-rpc/'>中间件,rpc</a>


</div>
	
	<div class="comments"><a href="/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/27/gao-bing-fa-miao-sha-xi-tong-de-she-ji/">
		
			高并发系统的设计及秒杀实践</a>
	</h2>
	<div class="entry-content">
		<p>一个大型网站应用一般都是从最初小规模网站甚至是单机应用发展而来的，为了让系统能够支持足够大的业务量，从前端到后端也采用了各种各样技术，前端静态资源压缩整合、使用CDN、分布式SOA架构、缓存、数据库加索引、读写分离等等。
这些技术是高并发系统所必须的，但是今天先不细说，而先谈谈在这些架构既定的情况下，一些高并发业务/接口实现时应该注意的原则，以及通过工作中遇到的一个6万QPS的秒杀活动，来介绍一下秒杀业务的特点以及如何优化。</p>

<h1>高并发系统设计原则</h1>

<p>高并发的接口/系统有一个共同的特性，那就是&#8221;快&#8221;。 <br/>
在系统其它条件既定的情况下，系统处理请求越快，用户得到反馈的时间就越短，单位时间内服务器能够处理请求的数量就会越多。所以”快&#8221;几乎可以算是高并发系统的要满足的必要条件，要评估一个系统性能如何，某次优化是否提高系统的容量，”快”是一个很直观的衡量标准。</p>

<p>那么，如何才能做得快呢？有两个需要注意的原则 <br/>
1.  做得少，一方面是指在功能特性上有所为，有所不为，另一方面是指一次处理的信息量要少。 <br/>
2.  做得巧，根据业务自身的特点，选择合理的业务实现方式，选择合理的缓存类型和缓存调用时机。</p>

<h2>做得少</h2>

<p>世界上最快的程序，是什么都不做的程序。 <br/>
一个接口负责的功能越少，读取信息量越少，速度越快。</p>

<h3>功能特性有选择</h3>

<p>对于一个需要承受高并发的接口，在功能上，尽量不涉及一些难以缓存和预热的数据。
一个典型的例子，用户维度个性化的数据，用户和用户的信息不同，userId数量又很多，即使加上缓存，缓存命中率依然很低，压力还是会打到数据库，不光接口快不了，高并发的sql也会给数据库带来风险。</p>

<p>举一个例子，在点评电影早期的秒杀活动页上，展示了一个用户当前秒杀资格的信息，由于不同用户抢到秒杀资格的时间、优惠不同，每次都需要读数据库的来取，也就是每个用户进入主页都会产生一条sql。 <br/>
还有一个例子，一般电商搞大促的时候，比如同时有多个优惠活动可以降低商品的价格，而一般只展示最低价的优惠，同时用户一个优惠只能参与一次，这样不同用户参与了不同活动之后可以享受的最低价就会随之改变，如果要在商品页面上展示这个动态价格，就免不了取到各个用户参加这些在线优惠的信息。</p>

<p>如果遇到这样的数据，要怎么解决呢？ <br/>
一个办法是尝试转移数据的维度：刚才说的秒杀活动资格信息，如果以用户userId为key，会出现缓存命中率低，仍要sql读的情况，但是能够秒到的用户数量其实很少，所以如果以这次秒杀活动id为key，存储一个成功秒到用户的userid的list，就能够解决缓存命中率低的问题。</p>

<p>还有一个办法是可以把这些需要个性化数据的功能在业务流程上后移，流量漏斗，越往后流量越少，创建订单级的sql查询是可接受的。
刚才说的第二个例子，商品最优惠的价格，可以排除用户相关信息，只在商品列表/详情上展示只和优惠相关的最低价，而在提交订单的时候才真正去取用户参加活动情况，如果用户已经参加过给出提示并选择次优的优惠。商品的列表/详情页都在用户路径上相对靠前的位置，排除了用户个性化信息可以让商品列表/详情更容易缓存，响应速度更快，系统可承受的高并发量更高。</p>

<h3>处理信息量要少</h3>

<p>我们写业务代码的时候都有对应的业务对象，它们都存在一定的业务范围之内，比如类目、地区、日期等自身相关的维度。
一个系统中的业务对象，在多个维度的细分下，对应的量并不多，但如果一次全部都展示在一个页面/接口下，即使覆盖上了缓存，也会由于缓存占用空间过大或者缓存key数目过多、网络传输耗时、对象序列化反序列耗时等拖慢接口/页面响应速度。一般只要看一下这个页面/接口给出的业务对象的数量级，就能大致知道这个接口的性能了。</p>

<p>大家在做设计的时候，一般会估算一个接口的量级，如果一看就有几千几万个业务对象，就不会这样设计了，但是需要警惕的是业务对象数量级可变的情况，比如随着业务发展数量会快速增长，或者某些特殊维度下业务对象特别多。设计的时候要按照预估的最大量级来，并且对接口/页面做出数量的限制，如果发现当前返回的业务对象过多，可以继续根据业务维度来拆分，分次分批来处理。</p>

<p>举一个例子，比如一个影院下所有的活动场次，开始的时候一家影院下的场次有限，几十一百场，很好展示，后来随着业务发展，一个影院下各个影院下场次数到了几百一千，一次全部拿完，在高并发时，memcached缓存的multi get会出现很多超时，请求会打到mysql数据库，给系统很大压力。之后我们做了改造项目，每次根据用户的交互按照影片、日期、影院的维度来分批取，一次只有十几个场次，接口响应变快了，服务的压力也小的多。</p>

<h2>做得巧</h2>

<h3>根据业务特性选择实现方式</h3>

<p>平时涉及到的业务，总有属于它的特性，比如实时性要求多高，数据一致性要求多高，涉及什么维度的数据，量有多大等等，我们要根据这些特性来选择实现的方案，比如一些统计数据，如某类目下所有商品的最低价，按照逻辑需要遍历商品来获取，但这样每次实时读取所有的对象，涉及读取缓存数据库操作，接口会很耗时，但如果选择作业离线计算，把计算结果写表，加上缓存，搜索直接读取，显然会快很多了。</p>

<p>涉及到业务各阶段特性的例子就是秒杀系统，在第二部分秒杀实践中我会详细介绍。</p>

<h3>合适选择和调用缓存</h3>

<p>除了业务特性方面，缓存是业务对抗高并发非常重要的一个环节，合理选择缓存的类型和调用缓存的时机非常重要。</p>

<p>我们知道内存运算速度快于远程连接，所以存储上来说效率如下
内存 &lt;= ehcache &lt; redis &lt;= memcached &lt; mysql
可以看出，尽量少的远程连接，常规覆盖数据库访问的缓存，都能提高程序的性能。</p>

<p>要根据不同缓存的特性和原理，才能根据业务选出最合适的，来看看几种常用的缓存 <br/>
1.  varnish，可以作为反向代理，缓存一些资源，例如可以把struts，freemarker动态生成的页面存储起来，达到直接挡掉到达web服务器的请求。 <br/>
2.  ehcache，主要存储在当前机器内存中，存取非常快，缺点是内存有限，各台机器内存中各存一份，失效时间不一致，数据就会出现不一致，一般用来缓存不常变化，且缓存个数较少的数据。 <br/>
3.  memcached缓存，kv分布式缓存集群，可扩展性好，可以存储个数较多的缓存对象，也可以承接高流量的访问，读取缓存时远程连接，一般耗时也在零点几到几ms不等。 <br/>
4.  redis，nosql，是内存的kv存储，可以做为缓存使用，也可以持久化，它的性能和memcached相近。而redis最大的特点是一个data-structure store，这时redis官网首页介绍redis的第一句话，它可以保存list，hash，set，sorted set等数据结构，使用时和memcached区别是，它不用将数据取到客户端再做逻辑判断，而是可以直接在redis服务器上完成操作，比如查看某个元素是不是一个范围内，队列的长度有多长等。redis可以用来做分布式服务器的进程间的通信，比如我们经常有需要分布式锁的场景，控制同一个用户发券的并发等。</p>

<p>根据业务需要选择了合适类型的缓存后，还要合理去使用。
虽然说缓存是为了抵挡数据库的流量而生，本身性能非常强大，但仍然是受到缓存服务器性能甚至服务器网卡流量的限制的，不合理的使用比如单个key对应的缓存对象过大、一次读取中缓存key数量过多、短时间内频繁更新缓存等都是系统的隐患、并发越高时就越能体现。</p>

<h1>秒杀实践</h1>

<h2>秒杀业务分析</h2>

<p>秒杀业务的典型特点有： <br/>
1.  瞬时流量大 <br/>
2.  参与用户多，可秒杀商品数量少 <br/>
3.  请求读多写少 <br/>
4.  秒杀状态转换实时性要求高</p>

<p>一次秒杀的流程可以分为三个阶段：  <br/>
1.  活动未开始 <br/>
活动开始前，用户进入活动页，这个阶段有两种请求，一种是加载活动页信息，一个是查询活动状态得到未开始的结果，
一个用户进入页面两个请求各发起一次，这两种请求占比各半。    <br/>
2.  活动进行中 <br/>
这个阶段持续时间非常短，看到抢购按钮的用户大量发起秒杀请求，瞬时秒杀请求占比增高，能不能抗住秒杀请求就是秒杀系统是否能抗住高并发的关键。   <br/>
3.  活动结束 <br/>
当商品被抢购完，进入结束状态，请求情况同活动开始前</p>

<p><img src="/assets/img/seckill/requestflow.png" alt="各阶段流量图" /> <br/>
其实贯穿整个活动的只有三种请求，加载活动页请求，读取活动状态请求，秒杀请求</p>

<h2>加载活动页请求</h2>

<p>主要是展示活动相关配置信息，活动背景图片，优惠力度，活动规则等相对静态的内容，通过web项目渲染成页面。</p>

<p>对于这样的请求，我们可以使用varnish反向代理，以页面相关的参数比如本次秒杀的活动ID和城市ID的hash为key把整个页面缓存在varnish机器上，而秒杀活动的状态等动态信息通过ajax来刷新。 <br/>
<img src="/assets/img/seckill/varnish.jpeg" alt="varnish作用机制" /></p>

<p>达到的效果是活动期间，加载页面请求都会打到varnish机器直接返回，而不会给web和service带来任何压力。</p>

<h2>查询活动状态</h2>

<p>秒杀状态就三种，未开始，可抢，已抢完，由两个因素共同决定  <br/>
1.  活动开始时间 <br/>
2.  剩余库存</p>

<p>读取秒杀状态的请求数并发也是非常高的，对于这个接口也要加上合适的缓存来处理。
对于活动开始时间，是一个较固定且不会发生变化的属性，并且，同时在线的秒杀活动数目并不多，所以把它也作为discount相关的信息，选择用响应快的ehcache来缓存。</p>

<p>对于库存，剩余库存个数，一般来说是全局需要一致的，可以用memcached来缓存，在秒杀的过程中，库存变化的非常快，如果直接对库存个数进行缓存，那么秒杀期间就需要频繁的更新缓存，像之前说的，虽然缓存是用来扛并发的，但要调用缓存的时机也要合理，memcached处理的并发请求越少，相对成功率就会越高。
其实对于秒杀活动来说，当时的剩余库存数在秒杀期间变化非常快，某个时间点上的库存个数并没有太大的意义，而用户更关心的是 能不能抢，true or false。如果缓存true or false的话，这个值在秒杀期间是相对稳定的，只需要在库存耗尽的时候更新一次，而且为了防止这一次的更新失败，可以重复更新，利用memcached的cas操作，最后memcached也只会真正执行一次set写操作。
因为秒杀期间查询活动状态的请求都打在memcached上，减少写的频率可以明显减轻memcached的负担。</p>

<p>其实活动状态除了活动时间和库存之外，还有第三个因素来决定，下面说到秒杀请求的优化时会详细来说</p>

<h2>秒杀请求</h2>

<h3>秒杀请求分析</h3>

<p>秒杀请求是一个秒杀系统能不能抗住高并发的关键
因为秒杀请求和之前两个请求不同，它是写请求，不能缓存，而且是活动峰值的主力。</p>

<p>一个用户从发出秒杀请求到成功秒杀简单地说需要两个步骤：
1.  扣库存
2.  发送秒杀商品
这是至少两条数据库操作，而且扣库存的这一步，在mysql的innodb引擎行锁机制下，update的sql到了数据库就开始排队，期间数据库连接是被占用的，当请求足够多时就会造成数据库的拥堵。
可以看出，秒杀请求接口是一个耗时相对长的接口，而且并发越高耗时越长，所以首先，一定要限制能够真正进行秒杀的人数。</p>

<p><img src="/assets/img/seckill/seckill.png" alt="秒杀流程图" /></p>

<p>上面说了，秒杀业务的一个特点是参与人数多，但是可供秒杀的商品少，也就是说只有极少部分的用户最终能够秒杀成功
比如有2500个名额，理论上来说先发送请求的2500个用户能够秒杀成功，这2500个用户扣库存的sql在数据库排队的时候，库存还没有消耗完，比如2500个请求，全部排队更新完是需要时间的，就比如说0.5s
在这个时间内，用户会看到当前仍然是可抢状态，所以这段时间内持续会有秒杀请求进入，秒杀的高峰期，0.5秒也有几万的请求，让几万条sql来竞争是没有意义的，所以要限制这些参与到扣库存这一步的人数。</p>

<h3>秒杀队列校验</h3>

<p>可抢状态需要第三个因素来决定，那就是当前秒杀的排队人数。
加在判断库存剩余之前，挡上一层排队人数的校验，
即有库存 并且 排队人数 &lt; 限制请求数 = 可抢，有库存 并且 排队人数 >= 限制请求数 = 抢完</p>

<p>比如2500个名额秒杀名额，目标放过去3000个秒杀请求</p>

<p>那么排队人数记在哪里？
这个可以有所选择，如果只记请求个数，可以用memcached的计数，一个用户进入秒杀流程increase一次，判断库存之前先判断队列长度，这样就限制了可参与秒杀的用户数量。</p>

<p><img src="/assets/img/seckill/newseckill.png" alt="排队秒杀流程图" /></p>

<p>发起秒杀先去问排队队列是不是已满，满了直接秒杀失败，同时可以去更新之前缓存了是否可抢 true or false的缓存，直接把前台可抢的状态变为不可抢。没满继续查询库存等后续流程，开始扣库存的时候，把当前用户id入队。
这样，就限制了真正进入秒杀的人数。</p>

<p>这种方法，可能会有一个问题，既然限制了请求数，那就必须要保证放过去的用户能够秒完商品，假设有重复提交的用户，如果重复提交的量大，比如放过去的请求中有一半都是重复提交，就会造成最后没秒完的情况，怎么屏蔽重复用户呢？
就要有个地方来记参与的用户id，可以使用redis的set结构来保存，这个时候set的size代表当前排队的用户数，扣库存之前add当前用户id到set，根据add是否成功的结果，来判断是否继续处理请求。</p>

<p>最终，把实际上几万个参与数据库操作的用户从减少到秒杀商品的级别，这是一个数据库可控制的范围，即使参与的用户再多，实际上也只处理了秒杀商品数量级的请求。</p>

<h3>更多的优化</h3>

<p>1.分库存
一般这样做就已经能够满足常规秒杀的需求了，但有一个问题依然没有解决，那就是加锁扣库存依然很慢
假设的活动秒杀的商品量能够再上一个量级，像小米卖个手机，一次有几W到几十万的时候，数据库也是扛不住这个量的，可以先把库存数放在redis上，然而单一库存加锁排队依然存在，库存这个热点数据会成为扣库存的瓶颈。</p>

<p>一个解决的办法是 分库存，比如总共有50000个秒杀名额，可以分50份，放在redis上的50个不同的key，那么每份上1000个库存，用户进入秒杀流程后随机到其中一个库存来修改，这样有50个库存数来竞争，缩短请求的排队时间。</p>

<p>这样专门为高并发设计的系统最大的敌人 是低流量，在大部分库存都好近，而有几个剩余库存时，
用户会看到明明还能抢却总是抢不到，而在高并发下，用户根本就觉察不到。</p>

<p>2.异步消息
如果有必要继续优化，就是扣库存和发货这两个费时的流程，可以改为异步，得到秒杀结果后通过短信/push异步通知用户。
主要是利用消息系统削峰填谷的特性 来增加系统的容量。</p>

<h2>秒杀总结</h2>

<p><img src="/assets/img/seckill/result.png" alt="流量图" /> <br/>
先用varnish挡掉了所有的读取状态请求
然后用ehcache缓存活动时间，挡掉活动未开始时查询活动状态的请求
memcached缓存是否可抢的状态，挡掉活动开始后到结束状态的活动查询请求
redis队列挡掉了活动进行中，过量的秒杀请求
到最后只留下了秒杀商品数量级的请求到数据库中。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-27T21:23:32+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/xi-tong-she-ji/'>系统设计</a>


</div>
	
	<div class="comments"><a href="/blog/2015/07/27/gao-bing-fa-miao-sha-xi-tong-de-she-ji/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2016

    xuanchen.zhao

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zxcgitblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-69206979-1']);
		_gaq.push(['_setDomainName','github.io']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>



</body>
</html>