
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>xuanchen&#8217;s Blog</title>
	<meta name="author" content="xuanchen.zhao">

	
	<meta name="description" content="一.RPC概述 RPC即是远程过程调用(Remote Procedure Call)，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。 现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成， &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="xuanchen's Blog" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">xuanchen&#8217;s Blog</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="https://www.google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:zxcpro.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="https://www.google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:zxcpro.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner">


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/">
		
			从零开始实现RPC框架&#8211;(1)基本原理</a>
	</h2>
	<div class="entry-content">
		<h1>一.RPC概述</h1>

<p>RPC即是远程过程调用(Remote Procedure Call)，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。</p>

<p>现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成，分布式的应用可以借助rpc来完成机器之间的调用。</p>

<h1>二.RPC框架原理</h1>

<p>在RPC框架中主要有两个角色，client和server。一台服务器作为server向外提供服务，同时其内部又调用了其它的服务，这时它也是另外一个服务的client。</p>

<h2>1.RPC框架原理</h2>

<p>下面通过分析一下一次rpc调用的过程来大致了解RPC的原理</p>

<p><img src="/assets/img/rpc/rpcflow.png" alt="RPC调用流程" /></p>

<ol>
<li>客户端调用了某个服务的某个方法，期望得到处理的结果</li>
<li>把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</li>
<li>根据被调用的服务名，方法签名等信息找到可以提供服务的server列表</li>
<li>根据负载均衡的规则，选出其中一个server作为目标来调用</li>
<li>向选出的server发送该请求</li>
<li>server接收到请求，反序列并解析得到对应的服务名，方法签名，参数信息</li>
<li>server根据调用信息找到真正的业务服务实例，调用业务服务该方法</li>
<li>把方法的返回值序列化，构造返回response</li>
<li>把response传回给client</li>
<li>client接收并反序列化response，得到服务处理结果，返回给1中调用的地方</li>
</ol>


<h2>2.实现RPC要解决的问题</h2>

<p>原理并不复杂，但实现起来每一个步骤中都有需要解决的问题，对应一种或多种解决的方案，一个个来分析：</p>

<h3>1.客户端调用了某个服务的某个方法，期望得到处理的结果</h3>

<p>Q：如何自然的发起RPC调用？ <br/>
client调用服务时希望尽量能够自然，就像在调用本地方法一样，比如要调用的服务是UserService，那么希望调用的时候也是userService.getUser(userId)这样的形式，客户端代码编写阶段就清晰的看到服务可提供的方法的签名 <br/>
A:利用代理模式，这里需要的是一个和userService有一样接口的代理，在其方法被调用的时候执行远程请求的逻辑，以java为例，可以用JDK的动态代理代理或者AOP来实现。</p>

<h3>2.把本次调用的上下文，如服务名、方法签名、参数等信息序列化，构造request</h3>

<p>Q:如何进行序列化？ <br/>
序列化其实是协议的一部分，网络一端以什么样的规则把数据对象序列化成二进制串，网络传输到了另一端后以什么样的规则解析回来。 <br/>
A:成熟的序列化实现方式已经有很多，不需要自己来实现，比如JDK自带的序列化，jackson，hession，protostuff等，我们会根据各种序列化的速度，序列化后占用空间大小等方面来选择，详见<a href="https://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking">各种序列化性能比较</a>。</p>

<h3>3.根据被调用的该服务名，方法签名 找到可以提供服务的server列表</h3>

<p>Q:server列表存在哪里？ <br/>
A:这里所说的是一个服务注册中心，在组件启动的时候可以加载当前正在提供服务的server列表，这意味注册中心需要能够存储这个列表，并且在server服务器上/下线、心跳中断/恢复时及时更新列表，并且注册中心必须保证高可用，不能由于一两台机器挂掉就变得不可用，也就是说需要集群和冗余的支持。听起来有些复杂，其实业界已经有成熟的方案了，可以选择利用zookeeper来实现，其高可用性，支持集群和冗余，pub/sub的功能都是注册中心需要的。 <br/>
另外，除了注册中心外，client上也可以在内存中维护一份列表，启动时访问注册中心初始化，在注册中心列表变化时接收通知同步修改，这样做的好处是不用每次调用都访问注册中心。</p>

<h3>4.根据负载均衡的规则，选出其中一个server作为目标来调用</h3>

<p>Q:负载均衡由谁实现？如何实现？负载均衡的策略如何？ <br/>
A:负载均衡可以作为独立模块，也可以直接放在客户端中，两种方案各有利弊: <br/>
独立部署的好处是客户端的职责单一，只负责调用，负载均衡模块可以根据全局的服务器状态来选择合适的server，缺点是客户端每次请求都要到负载均衡中心去请求server地址，多了一次网络请求，而且如果负载均衡中心挂了，服务就会立刻不能访问。
如果放在客户端上，客户端本地也维护一套注册中心的server列表，并且接收注册中心消息进行同步变更，每次就可以直接从本地的server列表中取出使用，但是这时的负载均衡策略就只能根据当前客户端调用server的情况来进行，比如当前客户端列表中有a，b，c三个server，可以轮询访问，从所有的客户端角度来看也是均衡的。</p>

<h3>5.向第4步中选出的server发送该请求</h3>

<p>Q:如何选择网络传输协议？同步/异步IO？ <br/>
A:网络传输协议的选择，常用的一般有TCP和HTTP两种方式，TCP方式传输效率高，但是实现起来复杂，HTTP方式更通用，开发起来更简单，但是传输效率不高。
同步的发送方式是发出请求后线程阻塞等待服务处理返回，实现起来容易，但是性能会差很多，一次请求发出后，在服务端处理逻辑时，IO阻塞没有得到充分的利用。而在异步IO的情况下，请求传输到服务端时IO不阻塞，继续处理其它的数据传输，而等服务端完成逻辑计算后再来传输，系统吞吐量会大很多。但是异步IO实现起来会比较复杂，一般我们借助netty，mina等nio通讯框架实现。</p>

<h3>6.server接收到请求，反序列化并解析得到对应的服务名，方法签名，参数信息</h3>

<p>Q:如果RPC支持多种序列化方式的扩展，接收的一端如何知道用哪种方式来进行反序列化？ <br/>
A:得到二进制串之后，如果是可支持多种序列化协议的，需要我们自己做一部分的二进制串解析工作，比如我们约定第第一个字节代表选择序列化的方式，收到二进制串后先读出这个字节，选择对应的反序列化协议解析后面的字节。</p>

<h3>7.server根据调用信息找到真正的业务服务实例，调用业务服务该方法</h3>

<p>Q:如何根据服务名，函数参数找到对应的服务实例？ <br/>
A:一般的应用都会用spring来管理，比如像服务中调用服务的service，让spring来管理，组装完成之后再返回使用起来非常方便，所以我们要根据服务名从spring中找到对应的bean，这里需要借助反射从服务名到class的转换，然后同样借助反射完成方法的调用。</p>

<h3>8.把方法的返回值序列化，构造返回response</h3>

<p>序列化时也要同6中所述，把序列化方式按照同样的规则写在二进制串中。</p>

<h3>9.把response传回给client</h3>

<p>对应步骤5中选择的网络协议及通讯方式实现</p>

<h3>10.client接收并反序列化response，得到服务处理结果，返回给步骤1中调用的地方</h3>

<p>Q:如果是异步调用，如何让客户端在调用时同步得到结果？ <br/>
A:这里涉及到一个异步转同步的问题，客户端在发出请求后，可以让当前线程等待在一个锁上，并把锁对象放在以该请求id为key的map中，而收到返回的response的回调时，根据reponse中的之前的请求Id从内存中的这个map中拿到这个锁，唤醒客户端线程，继续取走并返回的reponse。</p>

<p>这只是发起一次rpc请求所需要注意的点，除去这些之外，之前提到的服务注册中心及server/client与服务注册中心的交互也需要考虑：
1.client在启动时需要从服务注册中心同步自己关心的服务的地址列表，并在服务列表发生变化时更新列表。
2.server在启动时需要向服务注册中心注册自己能够提供服务的地址和端口，
3.监控系统定时向server发送心跳请求来确认server的可用性，如果不可用通知注册中心踢出列表，重试可用后再添加等。</p>

<p>下一篇我们将详细分析并实现RPC框架最根本的功能：远程调用的主流程，源码会放在git上供大家参考，如果问题，欢迎一起讨论。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-12-10T10:53:30+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/rpc/'>rpc</a>


</div>
	
	<div class="comments"><a href="/blog/2015/12/10/cong-ling-kai-shi-shi-xian-rpc-kuang-jia-1-ji-ben-yuan-li/#disqus_thread">Comments</a></div>
	
</div>
</article>


    <article class="post">
	<h2 class="title">
		
		<a href="/blog/2015/07/27/gao-bing-fa-miao-sha-xi-tong-de-she-ji/">
		
			高并发系统的设计及秒杀实践</a>
	</h2>
	<div class="entry-content">
		<p>一个大型网站应用一般都是从最初小规模网站甚至是单机应用发展而来的，为了让系统能够支持足够大的业务量，从前端到后端也采用了各种各样技术，前端静态资源压缩整合、使用CDN、分布式SOA架构、缓存、数据库加索引、读写分离等等。
这些技术是高并发系统所必须的，但是今天先不细说，而先谈谈在这些架构既定的情况下，一些高并发业务/接口实现时应该注意的原则，以及通过工作中遇到的一个6万QPS的秒杀活动，来介绍一下秒杀业务的特点以及如何优化。</p>

<h1>高并发系统设计原则</h1>

<p>高并发的接口/系统有一个共同的特性，那就是&#8221;快&#8221;。 <br/>
在系统其它条件既定的情况下，系统处理请求越快，用户得到反馈的时间就越短，单位时间内服务器能够处理请求的数量就会越多。所以”快&#8221;几乎可以算是高并发系统的要满足的必要条件，要评估一个系统性能如何，某次优化是否提高系统的容量，”快”是一个很直观的衡量标准。</p>

<p>那么，如何才能做得快呢？有两个需要注意的原则 <br/>
1.  做得少，一方面是指在功能特性上有所为，有所不为，另一方面是指一次处理的信息量要少。 <br/>
2.  做得巧，根据业务自身的特点，选择合理的业务实现方式，选择合理的缓存类型和缓存调用时机。</p>

<h2>做得少</h2>

<p>世界上最快的程序，是什么都不做的程序。 <br/>
一个接口负责的功能越少，读取信息量越少，速度越快。</p>

<h3>功能特性有选择</h3>

<p>对于一个需要承受高并发的接口，在功能上，尽量不涉及一些难以缓存和预热的数据。
一个典型的例子，用户维度个性化的数据，用户和用户的信息不同，userId数量又很多，即使加上缓存，缓存命中率依然很低，压力还是会打到数据库，不光接口快不了，高并发的sql也会给数据库带来风险。</p>

<p>举一个例子，在点评电影早期的秒杀活动页上，展示了一个用户当前秒杀资格的信息，由于不同用户抢到秒杀资格的时间、优惠不同，每次都需要读数据库的来取，也就是每个用户进入主页都会产生一条sql。 <br/>
还有一个例子，一般电商搞大促的时候，比如同时有多个优惠活动可以降低商品的价格，而一般只展示最低价的优惠，同时用户一个优惠只能参与一次，这样不同用户参与了不同活动之后可以享受的最低价就会随之改变，如果要在商品页面上展示这个动态价格，就免不了取到各个用户参加这些在线优惠的信息。</p>

<p>如果遇到这样的数据，要怎么解决呢？ <br/>
一个办法是尝试转移数据的维度：刚才说的秒杀活动资格信息，如果以用户userId为key，会出现缓存命中率低，仍要sql读的情况，但是能够秒到的用户数量其实很少，所以如果以这次秒杀活动id为key，存储一个成功秒到用户的userid的list，就能够解决缓存命中率低的问题。</p>

<p>还有一个办法是可以把这些需要个性化数据的功能在业务流程上后移，流量漏斗，越往后流量越少，创建订单级的sql查询是可接受的。
刚才说的第二个例子，商品最优惠的价格，可以排除用户相关信息，只在商品列表/详情上展示只和优惠相关的最低价，而在提交订单的时候才真正去取用户参加活动情况，如果用户已经参加过给出提示并选择次优的优惠。商品的列表/详情页都在用户路径上相对靠前的位置，排除了用户个性化信息可以让商品列表/详情更容易缓存，响应速度更快，系统可承受的高并发量更高。</p>

<h3>处理信息量要少</h3>

<p>我们写业务代码的时候都有对应的业务对象，它们都存在一定的业务范围之内，比如类目、地区、日期等自身相关的维度。
一个系统中的业务对象，在多个维度的细分下，对应的量并不多，但如果一次全部都展示在一个页面/接口下，即使覆盖上了缓存，也会由于缓存占用空间过大或者缓存key数目过多、网络传输耗时、对象序列化反序列耗时等拖慢接口/页面响应速度。一般只要看一下这个页面/接口给出的业务对象的数量级，就能大致知道这个接口的性能了。</p>

<p>大家在做设计的时候，一般会估算一个接口的量级，如果一看就有几千几万个业务对象，就不会这样设计了，但是需要警惕的是业务对象数量级可变的情况，比如随着业务发展数量会快速增长，或者某些特殊维度下业务对象特别多。设计的时候要按照预估的最大量级来，并且对接口/页面做出数量的限制，如果发现当前返回的业务对象过多，可以继续根据业务维度来拆分，分次分批来处理。</p>

<p>举一个例子，比如一个影院下所有的活动场次，开始的时候一家影院下的场次有限，几十一百场，很好展示，后来随着业务发展，一个影院下各个影院下场次数到了几百一千，一次全部拿完，在高并发时，memcached缓存的multi get会出现很多超时，请求会打到mysql数据库，给系统很大压力。之后我们做了改造项目，每次根据用户的交互按照影片、日期、影院的维度来分批取，一次只有十几个场次，接口响应变快了，服务的压力也小的多。</p>

<h2>做得巧</h2>

<h3>根据业务特性选择实现方式</h3>

<p>平时涉及到的业务，总有属于它的特性，比如实时性要求多高，数据一致性要求多高，涉及什么维度的数据，量有多大等等，我们要根据这些特性来选择实现的方案，比如一些统计数据，如某类目下所有商品的最低价，按照逻辑需要遍历商品来获取，但这样每次实时读取所有的对象，涉及读取缓存数据库操作，接口会很耗时，但如果选择作业离线计算，把计算结果写表，加上缓存，搜索直接读取，显然会快很多了。</p>

<p>涉及到业务各阶段特性的例子就是秒杀系统，在第二部分秒杀实践中我会详细介绍。</p>

<h3>合适选择和调用缓存</h3>

<p>除了业务特性方面，缓存是业务对抗高并发非常重要的一个环节，合理选择缓存的类型和调用缓存的时机非常重要。</p>

<p>我们知道内存运算速度快于远程连接，所以存储上来说效率如下
内存 &lt;= ehcache &lt; redis &lt;= memcached &lt; mysql
可以看出，尽量少的远程连接，常规覆盖数据库访问的缓存，都能提高程序的性能。</p>

<p>要根据不同缓存的特性和原理，才能根据业务选出最合适的，来看看几种常用的缓存 <br/>
1.  varnish，可以作为反向代理，缓存一些资源，例如可以把struts，freemarker动态生成的页面存储起来，达到直接挡掉到达web服务器的请求。 <br/>
2.  ehcache，主要存储在当前机器内存中，存取非常快，缺点是内存有限，各台机器内存中各存一份，失效时间不一致，数据就会出现不一致，一般用来缓存不常变化，且缓存个数较少的数据。 <br/>
3.  memcached缓存，kv分布式缓存集群，可扩展性好，可以存储个数较多的缓存对象，也可以承接高流量的访问，读取缓存时远程连接，一般耗时也在零点几到几ms不等。 <br/>
4.  redis，nosql，是内存的kv存储，可以做为缓存使用，也可以持久化，它的性能和memcached相近。而redis最大的特点是一个data-structure store，这时redis官网首页介绍redis的第一句话，它可以保存list，hash，set，sorted set等数据结构，使用时和memcached区别是，它不用将数据取到客户端再做逻辑判断，而是可以直接在redis服务器上完成操作，比如查看某个元素是不是一个范围内，队列的长度有多长等。redis可以用来做分布式服务器的进程间的通信，比如我们经常有需要分布式锁的场景，控制同一个用户发券的并发等。</p>

<p>根据业务需要选择了合适类型的缓存后，还要合理去使用。
虽然说缓存是为了抵挡数据库的流量而生，本身性能非常强大，但仍然是受到缓存服务器性能甚至服务器网卡流量的限制的，不合理的使用比如单个key对应的缓存对象过大、一次读取中缓存key数量过多、短时间内频繁更新缓存等都是系统的隐患、并发越高时就越能体现。</p>

<h1>秒杀实践</h1>

<h2>秒杀业务分析</h2>

<p>秒杀业务的典型特点有： <br/>
1.  瞬时流量大 <br/>
2.  参与用户多，可秒杀商品数量少 <br/>
3.  请求读多写少 <br/>
4.  秒杀状态转换实时性要求高</p>

<p>一次秒杀的流程可以分为三个阶段：  <br/>
1.  活动未开始 <br/>
活动开始前，用户进入活动页，这个阶段有两种请求，一种是加载活动页信息，一个是查询活动状态得到未开始的结果，
一个用户进入页面两个请求各发起一次，这两种请求占比各半。    <br/>
2.  活动进行中 <br/>
这个阶段持续时间非常短，看到抢购按钮的用户大量发起秒杀请求，瞬时秒杀请求占比增高，能不能抗住秒杀请求就是秒杀系统是否能抗住高并发的关键。   <br/>
3.  活动结束 <br/>
当商品被抢购完，进入结束状态，请求情况同活动开始前</p>

<p><img src="/assets/img/seckill/requestflow.png" alt="各阶段流量图" /> <br/>
其实贯穿整个活动的只有三种请求，加载活动页请求，读取活动状态请求，秒杀请求</p>

<h2>加载活动页请求</h2>

<p>主要是展示活动相关配置信息，活动背景图片，优惠力度，活动规则等相对静态的内容，通过web项目渲染成页面。</p>

<p>对于这样的请求，我们可以使用varnish反向代理，以页面相关的参数比如本次秒杀的活动ID和城市ID的hash为key把整个页面缓存在varnish机器上，而秒杀活动的状态等动态信息通过ajax来刷新。 <br/>
<img src="/assets/img/seckill/varnish.jpeg" alt="varnish作用机制" /></p>

<p>达到的效果是活动期间，加载页面请求都会打到varnish机器直接返回，而不会给web和service带来任何压力。</p>

<h2>查询活动状态</h2>

<p>秒杀状态就三种，未开始，可抢，已抢完，由两个因素共同决定  <br/>
1.  活动开始时间 <br/>
2.  剩余库存</p>

<p>读取秒杀状态的请求数并发也是非常高的，对于这个接口也要加上合适的缓存来处理。
对于活动开始时间，是一个较固定且不会发生变化的属性，并且，同时在线的秒杀活动数目并不多，所以把它也作为discount相关的信息，选择用响应快的ehcache来缓存。</p>

<p>对于库存，剩余库存个数，一般来说是全局需要一致的，可以用memcached来缓存，在秒杀的过程中，库存变化的非常快，如果直接对库存个数进行缓存，那么秒杀期间就需要频繁的更新缓存，像之前说的，虽然缓存是用来扛并发的，但要调用缓存的时机也要合理，memcached处理的并发请求越少，相对成功率就会越高。
其实对于秒杀活动来说，当时的剩余库存数在秒杀期间变化非常快，某个时间点上的库存个数并没有太大的意义，而用户更关心的是 能不能抢，true or false。如果缓存true or false的话，这个值在秒杀期间是相对稳定的，只需要在库存耗尽的时候更新一次，而且为了防止这一次的更新失败，可以重复更新，利用memcached的cas操作，最后memcached也只会真正执行一次set写操作。
因为秒杀期间查询活动状态的请求都打在memcached上，减少写的频率可以明显减轻memcached的负担。</p>

<p>其实活动状态除了活动时间和库存之外，还有第三个因素来决定，下面说到秒杀请求的优化时会详细来说</p>

<h2>秒杀请求</h2>

<h3>秒杀请求分析</h3>

<p>秒杀请求是一个秒杀系统能不能抗住高并发的关键
因为秒杀请求和之前两个请求不同，它是写请求，不能缓存，而且是活动峰值的主力。</p>

<p>一个用户从发出秒杀请求到成功秒杀简单地说需要两个步骤：
1.  扣库存
2.  发送秒杀商品
这是至少两条数据库操作，而且扣库存的这一步，在mysql的innodb引擎行锁机制下，update的sql到了数据库就开始排队，期间数据库连接是被占用的，当请求足够多时就会造成数据库的拥堵。
可以看出，秒杀请求接口是一个耗时相对长的接口，而且并发越高耗时越长，所以首先，一定要限制能够真正进行秒杀的人数。</p>

<p><img src="/assets/img/seckill/seckill.png" alt="秒杀流程图" /></p>

<p>上面说了，秒杀业务的一个特点是参与人数多，但是可供秒杀的商品少，也就是说只有极少部分的用户最终能够秒杀成功
比如有2500个名额，理论上来说先发送请求的2500个用户能够秒杀成功，这2500个用户扣库存的sql在数据库排队的时候，库存还没有消耗完，比如2500个请求，全部排队更新完是需要时间的，就比如说0.5s
在这个时间内，用户会看到当前仍然是可抢状态，所以这段时间内持续会有秒杀请求进入，秒杀的高峰期，0.5秒也有几万的请求，让几万条sql来竞争是没有意义的，所以要限制这些参与到扣库存这一步的人数。</p>

<h3>秒杀队列校验</h3>

<p>可抢状态需要第三个因素来决定，那就是当前秒杀的排队人数。
加在判断库存剩余之前，挡上一层排队人数的校验，
即有库存 并且 排队人数 &lt; 限制请求数 = 可抢，有库存 并且 排队人数 >= 限制请求数 = 抢完</p>

<p>比如2500个名额秒杀名额，目标放过去3000个秒杀请求</p>

<p>那么排队人数记在哪里？
这个可以有所选择，如果只记请求个数，可以用memcached的计数，一个用户进入秒杀流程increase一次，判断库存之前先判断队列长度，这样就限制了可参与秒杀的用户数量。</p>

<p><img src="/assets/img/seckill/newseckill.png" alt="排队秒杀流程图" /></p>

<p>发起秒杀先去问排队队列是不是已满，满了直接秒杀失败，同时可以去更新之前缓存了是否可抢 true or false的缓存，直接把前台可抢的状态变为不可抢。没满继续查询库存等后续流程，开始扣库存的时候，把当前用户id入队。
这样，就限制了真正进入秒杀的人数。</p>

<p>这种方法，可能会有一个问题，既然限制了请求数，那就必须要保证放过去的用户能够秒完商品，假设有重复提交的用户，如果重复提交的量大，比如放过去的请求中有一半都是重复提交，就会造成最后没秒完的情况，怎么屏蔽重复用户呢？
就要有个地方来记参与的用户id，可以使用redis的set结构来保存，这个时候set的size代表当前排队的用户数，扣库存之前add当前用户id到set，根据add是否成功的结果，来判断是否继续处理请求。</p>

<p>最终，把实际上几万个参与数据库操作的用户从减少到秒杀商品的级别，这是一个数据库可控制的范围，即使参与的用户再多，实际上也只处理了秒杀商品数量级的请求。</p>

<h3>更多的优化</h3>

<p>1.分库存
一般这样做就已经能够满足常规秒杀的需求了，但有一个问题依然没有解决，那就是加锁扣库存依然很慢
假设的活动秒杀的商品量能够再上一个量级，像小米卖个手机，一次有几W到几十万的时候，数据库也是扛不住这个量的，可以先把库存数放在redis上，然而单一库存加锁排队依然存在，库存这个热点数据会成为扣库存的瓶颈。</p>

<p>一个解决的办法是 分库存，比如总共有50000个秒杀名额，可以分50份，放在redis上的50个不同的key，那么每份上1000个库存，用户进入秒杀流程后随机到其中一个库存来修改，这样有50个库存数来竞争，缩短请求的排队时间。</p>

<p>这样专门为高并发设计的系统最大的敌人 是低流量，在大部分库存都好近，而有几个剩余库存时，
用户会看到明明还能抢却总是抢不到，而在高并发下，用户根本就觉察不到。</p>

<p>2.异步消息
如果有必要继续优化，就是扣库存和发货这两个费时的流程，可以改为异步，得到秒杀结果后通过短信/push异步通知用户。
主要是利用消息系统削峰填谷的特性 来增加系统的容量。</p>

<h2>秒杀总结</h2>

<p><img src="/assets/img/seckill/result.png" alt="流量图" /> <br/>
先用varnish挡掉了所有的读取状态请求
然后用ehcache缓存活动时间，挡掉活动未开始时查询活动状态的请求
memcached缓存是否可抢的状态，挡掉活动开始后到结束状态的活动查询请求
redis队列挡掉了活动进行中，过量的秒杀请求
到最后只留下了秒杀商品数量级的请求到数据库中。</p>

		
		
	</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-07-27T21:23:32+08:00" pubdate data-updated="true"></time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/xi-tong-she-ji/'>系统设计</a>


</div>
	
	<div class="comments"><a href="/blog/2015/07/27/gao-bing-fa-miao-sha-xi-tong-de-she-ji/#disqus_thread">Comments</a></div>
	
</div>
</article>

<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    xuanchen.zhao

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->


<script type="text/javascript">
      var disqus_shortname = 'zxcgitblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





</body>
</html>