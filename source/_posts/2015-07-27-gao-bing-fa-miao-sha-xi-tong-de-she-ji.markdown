---
layout: post
title: "高并发秒杀系统的设计"
date: 2015-07-27 21:23:32 +0800
comments: true
categories: 
---
##高并发秒杀系统的特点
秒杀类活动的特点是参与人数多，商品数量少，而且瞬时流量高，读多写少，秒杀状态变化的实时性要求高。系统需要能够承受住高峰时的流量，进入页面的用户及时看到当前活动的状态，参与秒杀的用户快速获得秒杀结果。同时作为营销类活动，一般是周期性的，也要考虑其可运营性，最好是模板化的，每次上新的活动由运营人员配置发布，不需要开发测试运维人员过多介入。

##秒杀系统要点
秒杀系统面临最大的问题就是大流量高并发，解决问题的办法很多，本质都是一样的：从web页面到服务，从服务到数据库，层层限流，同时每一层集群支持横向扩展，最终把压力限制在各层各台机器的可承受范围之内。
一般大型网站的正常业务上也都已经在使用分布式集群、服务化等，在秒杀系统上没有特殊之处，不再赘述，重点说说关于秒杀限流我的的一些思路：

####秒杀页面的限流--静态化
秒杀高峰时的请求有很大一部分是秒杀页面的展示请求，对页面静态化处理可以直接拦截这部分请求，减轻web项目的压力。
为了静态化的同时保持活动展示逻辑正确，抢购页面上的元素最好是静态的，而对于一些动态的元素，比如button是否可秒的状态，可以在html上存放活动开始时间戳，js比较当前时间来看活动是否开始，如果还未开始，button为不可抢，定时任务到点改变button状态，如果已经活动开始，ajax请求web查询当前是否仍然可以秒杀。

使用CDN/varnish都可以完成静态化的工作。考虑可运营的特性，需要根据配置生成新的活动页，使用CDN的方式需要导出静态html，上传和清除的api来完成自动上线，而使用varnish挡在web项目之前，根据模板生成的页面做缓存，则更简单直接一些。


####查询库存请求以及秒杀请求的限流
经过了前台静态化，到达web服务器的绝大多数是查询是否能够秒杀的请求和少量的秒杀下单请求。

正常的逻辑下，用户成功秒杀下单后扣除库存，直到库存耗尽，而查询请求直接查看数据库中是否还有剩余库存数。
但如果按照这个逻辑，大量的查询库存请求数据库难以承担，同时在秒杀时每个用户秒杀下单可能会涉及到若干个数据库操作，反应速度较慢，这样可秒杀状态会持续需要一段时间，在此期间秒杀下单的请求会持续大量进入，大量读和写的SQL会引起数据库缓慢、阻塞甚至崩溃，还会影响到所依赖的订单系统等。

其实秒杀商品的数量通常是很有限的，而放入过多的秒杀请求没有意义，我们可以对进行秒杀的用户请求数做控制，比如有100个秒杀名额时，放过200个请求就足够了。
我们需要记录有多少用户已经发出了秒杀请求，这样的数据需要记录在高并发的快速频繁读写的存储上，关系型数据库如mysql很难承担，一般需要结构化的nosql支持，比如redis，其数据结构如list，set等在该场景下也能发挥很大作用。
在发送秒杀请求之前检验nosql中记录的目前已经请求的人数，如果超过阈值直接返回秒杀失败，发出秒杀请求的时候在该活动秒杀人数上+1，而页面上的是否可继续秒杀的button状态直接使用改请求人数判断替换库存的查询，如果考虑用户重复请求的情况，可以用redis的set结构存储请求人的用户id来代替请求人数。
这样限制了秒杀请求的数量就减少了到下一层秒杀下单模块的压力，而且nosql充当了库存状态的缓存，未能参与秒杀的用户可以很快看到秒杀状态的改变。


####下单秒杀限流
经过web层的限流，如果100万用户前来参与秒杀，100万次页面展示请求被静态化服务器拦截，100万的查询库存请求被nosql拦截，最后到达数据库只剩下秒杀名额数量级的写请求，当然如果秒杀名额数量较多，下单请求并发仍然很高时，我们还可以使用队列机制，让秒杀请求排队一个个执行，实现方式使用异步消息队列最为自然，在用户秒杀成功后发出短信或者推送通知用户下单。






